{"version":3,"file":"323.f2dd167522868468.js","sources":["webpack://lcn-frontend/src/LitVirtualizer.ts","webpack://lcn-frontend/src/ScrollerController.ts","webpack://lcn-frontend/src/Virtualizer.ts","webpack://lcn-frontend/src/events.ts","webpack://lcn-frontend/src/lit-virtualizer.ts","webpack://lcn-frontend/src/virtualize.ts","webpack://lcn-frontend/src/async-directive.ts","webpack://lcn-frontend/../src/directives/repeat.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {html, LitElement} from 'lit';\nimport {property} from 'lit/decorators/property.js';\nimport {KeyFn} from 'lit/directives/repeat.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\nimport {\n  virtualize,\n  virtualizerRef,\n  VirtualizerHostElement,\n  defaultRenderItem,\n  defaultKeyFunction,\n  RenderItemFunction,\n} from './virtualize.js';\n\nexport class LitVirtualizer<T = unknown> extends LitElement {\n  @property({attribute: false})\n  items: T[] = [];\n\n  @property()\n  renderItem: RenderItemFunction<T> = defaultRenderItem;\n\n  @property()\n  keyFunction: KeyFn<T> = defaultKeyFunction;\n\n  @property({attribute: false})\n  layout: LayoutConfigValue = {};\n\n  @property({reflect: true, type: Boolean})\n  scroller = false;\n\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    const {items, renderItem, keyFunction, layout, scroller} = this;\n    return html`${virtualize({\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller,\n    })}`;\n  }\n\n  element(index: number) {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.element(index);\n  }\n\n  get layoutComplete() {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.layoutComplete;\n  }\n\n  /**\n   * This scrollToIndex() shim is here to provide backwards compatibility with other 0.x versions of\n   * lit-virtualizer. It is deprecated and will likely be removed in the 1.0.0 release.\n   */\n  scrollToIndex(\n    index: number,\n    position: 'start' | 'center' | 'end' | 'nearest' = 'start'\n  ) {\n    this.element(index)?.scrollIntoView({block: position});\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ScrollToCoordinates} from './layouts/shared/Layout.js';\n\ntype retargetScrollCallback = () => ScrollToCoordinates;\ntype endScrollCallback = () => void;\ntype Nullable<T> = T | null;\n\nexport class ScrollerShim {\n  protected _node: Element | Window;\n  protected _element: Nullable<Element> = null;\n\n  constructor(element?: Element) {\n    const node = element ?? window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n\n  public get element() {\n    return (\n      this._element || document.scrollingElement || document.documentElement\n    );\n  }\n\n  public get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n\n  public get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n\n  public get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n\n  public get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n\n  public get viewportHeight() {\n    return this._element\n      ? this._element.getBoundingClientRect().height\n      : window.innerHeight;\n  }\n\n  public get viewportWidth() {\n    return this._element\n      ? this._element.getBoundingClientRect().width\n      : window.innerWidth;\n  }\n\n  public get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n\n  public get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\n\nexport class ScrollerController extends ScrollerShim {\n  private _originalScrollTo:\n    | typeof Element.prototype.scrollTo\n    | typeof window.scrollTo;\n  private _originalScrollBy:\n    | typeof Element.prototype.scrollBy\n    | typeof window.scrollBy;\n  private _originalScroll:\n    | typeof Element.prototype.scroll\n    | typeof window.scroll;\n  private _clients = new Set<unknown>();\n  private _retarget: Nullable<retargetScrollCallback> = null;\n  private _end: Nullable<endScrollCallback> = null;\n  private __destination: Nullable<ScrollToOptions> = null;\n\n  constructor(client: unknown, element?: Element) {\n    super(element);\n\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n\n    const node = this._node;\n\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n\n  public correctingScrollError = false;\n\n  private get _destination() {\n    return this.__destination;\n  }\n\n  public get scrolling() {\n    return this._destination !== null;\n  }\n\n  public scrollTo(options: ScrollToOptions): void;\n  public scrollTo(x: number, y: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    this._scrollTo(options);\n  }\n\n  public scrollBy(options: ScrollToOptions): void;\n  public scrollBy(x: number, y: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n\n  private _nativeScrollTo(options: ScrollToOptions) {\n    this._originalScrollTo!.bind(this._element || window)(options);\n  }\n\n  private _scrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback | null = null,\n    end: endScrollCallback | null = null\n  ) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n\n  private _setDestination(options: ScrollToOptions) {\n    let {top, left} = options;\n    top =\n      top === undefined\n        ? undefined\n        : Math.max(0, Math.min(top, this.maxScrollTop));\n    left =\n      left === undefined\n        ? undefined\n        : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (\n      this._destination !== null &&\n      left === this._destination.left &&\n      top === this._destination.top\n    ) {\n      return false;\n    }\n    this.__destination = {top, left, behavior: 'smooth'};\n    return true;\n  }\n\n  private _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n\n  private _updateManagedScrollTo(coordinates: ScrollToCoordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n\n  public managedScrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback,\n    end: endScrollCallback\n  ) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n\n  public correctScrollError(coordinates: ScrollToCoordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() =>\n      requestAnimationFrame(() => (this.correctingScrollError = false))\n    );\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n\n  private _checkForArrival() {\n    if (this._destination !== null) {\n      const {scrollTop, scrollLeft} = this;\n      let {top, left} = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n\n  public detach(client: unknown) {\n    this._clients.delete(client);\n\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n\n  private _attach(client: unknown) {\n    this._clients.add(client);\n\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client â€“ otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ItemBox,\n  Margins,\n  LayoutConfigValue,\n  ChildPositions,\n  ChildMeasurements,\n  Layout,\n  LayoutConstructor,\n  LayoutSpecifier,\n  StateChangedMessage,\n  Size,\n  InternalRange,\n  MeasureChildFunction,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  LayoutHostMessage,\n} from './layouts/shared/Layout.js';\nimport {\n  RangeChangedEvent,\n  VisibilityChangedEvent,\n  UnpinnedEvent,\n} from './events.js';\nimport {ScrollerController} from './ScrollerController.js';\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver: typeof ResizeObserver | undefined =\n  typeof window !== 'undefined' ? window.ResizeObserver : undefined;\n\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor: typeof ResizeObserver) {\n  _ResizeObserver = Ctor;\n}\n\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    rangeChanged: RangeChangedEvent;\n    visibilityChanged: VisibilityChangedEvent;\n    unpinned: UnpinnedEvent;\n  }\n}\n\nexport interface VirtualizerHostElement extends HTMLElement {\n  [virtualizerRef]?: Virtualizer;\n}\n\n/**\n * A very limited proxy object for a virtualizer child,\n * returned by Virtualizer.element(idx: number). Introduced\n * to enable scrolling a virtual element into view using\n * a call that looks and behaves essentially the same as for\n * a real Element. May be useful for other things later.\n */\nexport interface VirtualizerChildElementProxy {\n  scrollIntoView: (options?: ScrollIntoViewOptions) => void;\n}\n\n/**\n * Used internally for scrolling a (possibly virtual) element\n * into view, given its index\n */\ninterface ScrollElementIntoViewOptions extends ScrollIntoViewOptions {\n  index: number;\n}\n\nexport interface VirtualizerConfig {\n  layout?: LayoutConfigValue;\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n  hostElement: VirtualizerHostElement;\n\n  scroller?: boolean;\n}\n\nlet DefaultLayoutConstructor: LayoutConstructor;\n\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  private _benchmarkStart: number | null = null;\n\n  private _layout: Layout | null = null;\n\n  private _clippingAncestors: HTMLElement[] = [];\n\n  /**\n   * Layout provides these values, we set them on _render().\n   * TODO @straversi: Can we find an XOR type, usable for the key here?\n   */\n  private _scrollSize: Size | null = null;\n\n  /**\n   * Difference between scroll target's current and required scroll offsets.\n   * Provided by layout.\n   */\n  private _scrollError: {left: number; top: number} | null = null;\n\n  /**\n   * A list of the positions (top, left) of the children in the current range.\n   */\n  private _childrenPos: ChildPositions | null = null;\n\n  // TODO: (graynorton): type\n  private _childMeasurements: ChildMeasurements | null = null;\n\n  private _toBeMeasured = new Map<HTMLElement, unknown>();\n\n  private _rangeChanged = true;\n\n  private _itemsChanged = true;\n\n  private _visibilityChanged = true;\n\n  /**\n   * The HTMLElement that hosts the virtualizer. Set by hostElement.\n   */\n  protected _hostElement?: VirtualizerHostElement;\n\n  private _scrollerController: ScrollerController | null = null;\n\n  private _isScroller = false;\n\n  private _sizer: HTMLElement | null = null;\n\n  /**\n   * Resize observer attached to hostElement.\n   */\n  private _hostElementRO: ResizeObserver | null = null;\n\n  /**\n   * Resize observer attached to children.\n   */\n  private _childrenRO: ResizeObserver | null = null;\n\n  private _mutationObserver: MutationObserver | null = null;\n\n  private _scrollEventListeners: (Element | Window)[] = [];\n  private _scrollEventListenerOptions: AddEventListenerOptions = {\n    passive: true,\n  };\n\n  // TODO (graynorton): Rethink, per longer comment below\n\n  private _loadListener = this._childLoaded.bind(this);\n\n  /**\n   * Index of element to scroll into view, plus scroll\n   * behavior options, as imperatively specified via\n   * `element(index).scrollIntoView()`\n   */\n  private _scrollIntoViewTarget: ScrollElementIntoViewOptions | null = null;\n\n  private _updateScrollIntoViewCoordinates:\n    | ((coordinates: ScrollToCoordinates) => void)\n    | null = null;\n\n  /**\n   * Items to render. Set by items.\n   */\n  private _items: Array<unknown> = [];\n\n  /**\n   * Index of the first child in the range, not necessarily the first visible child.\n   * TODO @straversi: Consider renaming these.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child in the range.\n   */\n  protected _last = -1;\n\n  /**\n   * Index of the first item intersecting the viewport.\n   */\n  private _firstVisible = -1;\n\n  /**\n   * Index of the last item intersecting the viewport.\n   */\n  private _lastVisible = -1;\n\n  protected _scheduled = new WeakSet<Function>();\n\n  /**\n   * Invoked at the end of each render cycle: children in the range are\n   * measured, and their dimensions passed to this callback. Use it to layout\n   * children as needed.\n   */\n  protected _measureCallback: ((sizes: ChildMeasurements) => void) | null =\n    null;\n\n  protected _measureChildOverride: MeasureChildFunction | null = null;\n\n  /**\n   * State for `layoutComplete` promise\n   */\n  private _layoutCompletePromise: Promise<void> | null = null;\n  private _layoutCompleteResolver: Function | null = null;\n  private _layoutCompleteRejecter: Function | null = null;\n  private _pendingLayoutComplete: number | null = null;\n\n  /**\n   * Layout initialization is async because we dynamically load\n   * the default layout if none is specified. This state is to track\n   * whether init is complete.\n   */\n  private _layoutInitialized: Promise<void> | null = null;\n\n  /**\n   * Track connection state to guard against errors / unnecessary work\n   */\n  private _connected = false;\n\n  constructor(config: VirtualizerConfig) {\n    if (!config) {\n      throw new Error(\n        'Virtualizer constructor requires a configuration object'\n      );\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error(\n        'Virtualizer configuration requires the \"hostElement\" property'\n      );\n    }\n  }\n\n  set items(items: Array<unknown> | undefined) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config: VirtualizerConfig) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || ({} as BaseLayoutConfig);\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n\n  private _initObservers() {\n    this._mutationObserver = new MutationObserver(\n      this._finishDOMUpdate.bind(this)\n    );\n    this._hostElementRO = new _ResizeObserver!(() =>\n      this._hostElementSizeChanged()\n    );\n    this._childrenRO = new _ResizeObserver!(\n      this._childrenSizeChanged.bind(this)\n    );\n  }\n\n  _initHostElement(config: VirtualizerConfig) {\n    const hostElement = (this._hostElement = config.hostElement);\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(\n      this._hostElement!,\n      includeSelf\n    );\n\n    this._scrollerController = new ScrollerController(\n      this,\n      this._clippingAncestors[0]\n    );\n\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n    this._connected = true;\n  }\n\n  _observeAndListen() {\n    this._mutationObserver!.observe(this._hostElement!, {childList: true});\n    this._hostElementRO!.observe(this._hostElement!);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach((ancestor) => {\n      ancestor.addEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      );\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO!.observe(ancestor);\n    });\n    this._hostElementRO!.observe(this._scrollerController!.element);\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._scrollEventListeners.forEach((target) =>\n      target.addEventListener('scroll', this, this._scrollEventListenerOptions)\n    );\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach((target) =>\n      target.removeEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      )\n    );\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController?.detach(this);\n    this._scrollerController = null;\n    this._mutationObserver?.disconnect();\n    this._mutationObserver = null;\n    this._hostElementRO?.disconnect();\n    this._hostElementRO = null;\n    this._childrenRO?.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n    this._connected = false;\n  }\n\n  private _applyVirtualizerStyles() {\n    const hostElement = this._hostElement!;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style as CSSStyleDeclaration & {contain: string};\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement!;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(\n        `[${SIZER_ATTRIBUTE}]`\n      ) as HTMLElement;\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px',\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n\n  async updateLayoutConfig(layoutConfig: LayoutConfigValue) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor =\n      ((layoutConfig as LayoutSpecifier).type as LayoutConstructor) ||\n      // The new config is compatible with the current layout,\n      // so we update the config and return true to indicate\n      // a successful update\n      DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete config.type;\n      this._layout.config = config as BaseLayoutConfig;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n\n  private async _initLayout(layoutConfig: LayoutConfigValue) {\n    let config: BaseLayoutConfig | undefined;\n    let Ctor: LayoutConstructor | undefined;\n    if (typeof (layoutConfig as LayoutSpecifier).type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = (layoutConfig as LayoutSpecifier).type as LayoutConstructor;\n      // ...while the rest of the specifier is our layout config\n      const copy = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete copy.type;\n      config = copy as BaseLayoutConfig;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig as BaseLayoutConfig;\n    }\n\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n        .FlowLayout as unknown as LayoutConstructor;\n    }\n\n    this._layout = new Ctor(\n      (message: LayoutHostMessage) => this._handleLayoutMessage(message),\n      config\n    );\n\n    if (\n      this._layout.measureChildren &&\n      typeof this._layout.updateItemSizes === 'function'\n    ) {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement!.addEventListener('load', this._loadListener, true);\n    }\n\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName(\n        'uv-virtualizing',\n        'measure'\n      );\n      const virtualizationTime = entries\n        .filter(\n          (e) => e.startTime >= this._benchmarkStart! && e.startTime < now\n        )\n        .reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {timeElapsed, virtualizationTime};\n    }\n    return null;\n  }\n\n  private _measureChildren(): void {\n    const mm: ChildMeasurements = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element: Element): ItemBox {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {width, height} = element.getBoundingClientRect();\n    return Object.assign({width, height}, getMargins(element));\n  }\n\n  protected async _schedule(method: Function): Promise<void> {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n\n  async _updateDOM(state: StateChangedMessage) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {_rangeChanged, _itemsChanged} = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n\n  _finishDOMUpdate() {\n    if (this._connected) {\n      // _childrenRO should be non-null if we're connected\n      this._children.forEach((child) => this._childrenRO!.observe(child));\n      this._checkScrollIntoViewTarget(this._childrenPos);\n      this._positionChildren(this._childrenPos);\n      this._sizeHostElement(this._scrollSize);\n      this._correctScrollError();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  _updateLayout() {\n    if (this._layout && this._connected) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  private _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController!.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      this._layout?.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event: CustomEvent) {\n    switch (event.type) {\n      case 'scroll':\n        if (\n          event.currentTarget === window ||\n          this._clippingAncestors.includes(event.currentTarget as HTMLElement)\n        ) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  _handleLayoutMessage(message: LayoutHostMessage) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement!.dispatchEvent(new UnpinnedEvent());\n    }\n  }\n\n  get _children(): Array<HTMLElement> {\n    const arr: Array<HTMLElement> = [];\n    let next = this._hostElement!.firstElementChild as HTMLElement;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling as HTMLElement;\n    }\n    return arr;\n  }\n\n  private _updateView() {\n    const hostElement = this._hostElement;\n    const scrollingElement = this._scrollerController?.element;\n    const layout = this._layout;\n\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n\n      const hostElementBounds = hostElement.getBoundingClientRect();\n\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n\n      const ancestorBounds = this._clippingAncestors.map((ancestor) =>\n        ancestor.getBoundingClientRect()\n      );\n      ancestorBounds.unshift(hostElementBounds);\n\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top,\n      };\n\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight,\n      };\n\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n\n      const height = Math.max(0, bottom - top);\n      const width = Math.max(0, right - left);\n\n      layout.viewportSize = {width, height};\n      layout.viewportScroll = {top: scrollTop, left: scrollLeft};\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  private _sizeHostElement(size?: Size | null) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement!.style;\n      (style.minWidth as string | null) = h ? `${h}px` : '100%';\n      (style.minHeight as string | null) = v ? `${v}px` : '100%';\n    }\n  }\n\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  private _positionChildren(pos: ChildPositions | null) {\n    if (pos) {\n      pos.forEach(({top, left, width, height, xOffset, yOffset}, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          (child.style.left as string | null) =\n            xOffset === undefined ? null : xOffset + 'px';\n          (child.style.top as string | null) =\n            yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  private async _adjustRange(range: InternalRange) {\n    const {_first, _last, _firstVisible, _lastVisible} = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged =\n      this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged =\n      this._visibilityChanged ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible;\n  }\n\n  private _correctScrollError() {\n    if (this._scrollError) {\n      const {scrollTop, scrollLeft} = this._scrollerController!;\n      const {top, left} = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController!.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left,\n      });\n    }\n  }\n\n  public element(index: number): VirtualizerChildElementProxy | undefined {\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return this._items?.[index] === undefined\n      ? undefined\n      : {\n          scrollIntoView: (options: ScrollIntoViewOptions = {}) =>\n            this._scrollElementIntoView({...options, index}),\n        };\n  }\n\n  private _scrollElementIntoView(options: ScrollElementIntoViewOptions) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout!.getScrollIntoViewCoordinates(options);\n        const {behavior} = options;\n        this._updateScrollIntoViewCoordinates =\n          this._scrollerController!.managedScrollTo(\n            Object.assign(coordinates, {behavior}),\n            () => this._layout!.getScrollIntoViewCoordinates(options),\n            () => (this._scrollIntoViewTarget = null)\n          );\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout!.pin = options;\n      }\n    }\n  }\n\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  private _checkScrollIntoViewTarget(pos: ChildPositions | null) {\n    const {index} = this._scrollIntoViewTarget || {};\n    if (index && pos?.has(index)) {\n      this._updateScrollIntoViewCoordinates!(\n        this._layout!.getScrollIntoViewCoordinates(this._scrollIntoViewTarget!)\n      );\n    }\n  }\n\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  private _notifyRange() {\n    this._hostElement!.dispatchEvent(\n      new RangeChangedEvent({first: this._first, last: this._last})\n    );\n  }\n\n  private _notifyVisibility() {\n    this._hostElement!.dispatchEvent(\n      new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible,\n      })\n    );\n  }\n\n  public get layoutComplete(): Promise<void> {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n\n  private _rejectLayoutCompletePromise(reason: string) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() =>\n        requestAnimationFrame(() => this._resolveLayoutCompletePromise())\n      );\n    }\n  }\n\n  private _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  private _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n  private _childLoaded() {}\n\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  private _childrenSizeChanged(changes: ResizeObserverEntry[]) {\n    // Only measure if the layout requires it\n    if (this._layout?.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(\n          change.target as HTMLElement,\n          change.contentRect\n        );\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\n\nfunction getMargins(el: Element): Margins {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft),\n  };\n}\n\nfunction getMarginValue(value: string): number {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el: Element) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return (parentNode as ShadowRoot).host || null;\n  }\n  return null;\n}\n\n///\n\nfunction getElementAncestors(el: HTMLElement, includeSelf = false) {\n  const ancestors: Array<HTMLElement> = [];\n  let parent = includeSelf ? el : (getParentElement(el) as HTMLElement);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent) as HTMLElement;\n  }\n  return ancestors;\n}\n\nfunction getClippingAncestors(el: HTMLElement, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter((a) => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport class RangeChangedEvent extends Event {\n  static eventName = 'rangeChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(RangeChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class VisibilityChangedEvent extends Event {\n  static eventName = 'visibilityChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(VisibilityChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class UnpinnedEvent extends Event {\n  static eventName = 'unpinned';\n\n  constructor() {\n    super(UnpinnedEvent.eventName, {bubbles: false});\n  }\n}\n\ninterface Range {\n  first: number;\n  last: number;\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {LitVirtualizer} from './LitVirtualizer.js';\nexport {LitVirtualizer};\nexport {RangeChangedEvent, VisibilityChangedEvent} from './events.js';\n\n/**\n * Import this module to declare the lit-virtualizer custom element.\n */\ncustomElements.define('lit-virtualizer', LitVirtualizer);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'lit-virtualizer': LitVirtualizer;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {TemplateResult, ChildPart, html, noChange} from 'lit';\nimport {directive, DirectiveResult, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {repeat, KeyFn} from 'lit/directives/repeat.js';\nimport {Virtualizer} from './Virtualizer.js';\nimport {RangeChangedEvent} from './events.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\n\nexport {virtualizerRef, VirtualizerHostElement} from './Virtualizer.js';\n\n/**\n * Configuration options for the virtualize directive.\n */\nexport interface VirtualizeDirectiveConfig<T> {\n  /**\n   * A function that returns a lit-html TemplateResult. It will be used\n   * to generate the DOM for each item in the virtual list.\n   */\n  renderItem?: RenderItemFunction<T>;\n\n  keyFunction?: KeyFn<T>;\n\n  scroller?: boolean;\n\n  // TODO (graynorton): Document...\n  layout?: LayoutConfigValue;\n\n  /**\n   * The list of items to display via the renderItem function.\n   */\n  items?: Array<T>;\n}\n\nexport type RenderItemFunction<T = unknown> = (\n  item: T,\n  index: number\n) => TemplateResult;\n\nexport const defaultKeyFunction: KeyFn<unknown> = (item: unknown) => item;\nexport const defaultRenderItem: RenderItemFunction<unknown> = (\n  item: unknown,\n  idx: number\n) => html`${idx}: ${JSON.stringify(item, null, 2)}`;\n\nclass VirtualizeDirective<T = unknown> extends AsyncDirective {\n  _virtualizer: Virtualizer | null = null;\n  _first = 0;\n  _last = -1;\n  _renderItem: RenderItemFunction<T> = (item: T, idx: number) =>\n    defaultRenderItem(item, idx + this._first);\n  _keyFunction: KeyFn<T> = (item: T, idx: number) =>\n    defaultKeyFunction(item, idx + this._first);\n  _items: Array<T> = [];\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type !== PartType.CHILD) {\n      throw new Error(\n        'The virtualize directive can only be used in child expressions'\n      );\n    }\n  }\n\n  render(config?: VirtualizeDirectiveConfig<T>) {\n    if (config) {\n      this._setFunctions(config);\n    }\n    const itemsToRender: Array<T> = [];\n\n    if (this._first >= 0 && this._last >= this._first) {\n      for (let i = this._first; i <= this._last; i++) {\n        itemsToRender.push(this._items[i]);\n      }\n    }\n    return repeat(itemsToRender, this._keyFunction, this._renderItem);\n  }\n\n  update(part: ChildPart, [config]: [VirtualizeDirectiveConfig<T>]) {\n    this._setFunctions(config);\n    const itemsChanged = this._items !== config.items;\n    this._items = config.items || [];\n    if (this._virtualizer) {\n      this._updateVirtualizerConfig(part, config);\n    } else {\n      this._initialize(part, config);\n    }\n    return itemsChanged ? noChange : this.render();\n  }\n\n  private async _updateVirtualizerConfig(\n    part: ChildPart,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    const compatible = await this._virtualizer!.updateLayoutConfig(\n      config.layout || {}\n    );\n    if (!compatible) {\n      const hostElement = part.parentNode as HTMLElement;\n      this._makeVirtualizer(hostElement, config);\n    }\n    this._virtualizer!.items = this._items;\n  }\n\n  private _setFunctions(config: VirtualizeDirectiveConfig<T>) {\n    const {renderItem, keyFunction} = config;\n    if (renderItem) {\n      this._renderItem = (item, idx) => renderItem(item, idx + this._first);\n    }\n    if (keyFunction) {\n      this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);\n    }\n  }\n\n  private _makeVirtualizer(\n    hostElement: HTMLElement,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    if (this._virtualizer) {\n      this._virtualizer.disconnected();\n    }\n    const {layout, scroller, items} = config;\n    this._virtualizer = new Virtualizer({hostElement, layout, scroller});\n    this._virtualizer.items = items;\n    this._virtualizer.connected();\n  }\n\n  private _initialize(part: ChildPart, config: VirtualizeDirectiveConfig<T>) {\n    const hostElement = part.parentNode as HTMLElement;\n    if (hostElement && hostElement.nodeType === 1) {\n      hostElement.addEventListener('rangeChanged', (e: RangeChangedEvent) => {\n        this._first = e.first;\n        this._last = e.last;\n        this.setValue(this.render());\n      });\n      this._makeVirtualizer(hostElement, config);\n    }\n  }\n\n  disconnected() {\n    this._virtualizer?.disconnected();\n  }\n\n  reconnected() {\n    this._virtualizer?.connected();\n  }\n}\n\nexport const virtualize = directive(VirtualizeDirective) as <T>(\n  config?: VirtualizeDirectiveConfig<T>\n) => DirectiveResult<typeof VirtualizeDirective>;\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Overview:\n *\n * This module is designed to add support for an async `setValue` API and\n * `disconnected` callback to directives with the least impact on the core\n * runtime or payload when that feature is not used.\n *\n * The strategy is to introduce a `AsyncDirective` subclass of\n * `Directive` that climbs the \"parent\" tree in its constructor to note which\n * branches of lit-html's \"logical tree\" of data structures contain such\n * directives and thus need to be crawled when a subtree is being cleared (or\n * manually disconnected) in order to run the `disconnected` callback.\n *\n * The \"nodes\" of the logical tree include Parts, TemplateInstances (for when a\n * TemplateResult is committed to a value of a ChildPart), and Directives; these\n * all implement a common interface called `DisconnectableChild`. Each has a\n * `_$parent` reference which is set during construction in the core code, and a\n * `_$disconnectableChildren` field which is initially undefined.\n *\n * The sparse tree created by means of the `AsyncDirective` constructor\n * crawling up the `_$parent` tree and placing a `_$disconnectableChildren` Set\n * on each parent that includes each child that contains a\n * `AsyncDirective` directly or transitively via its children. In order to\n * notify connection state changes and disconnect (or reconnect) a tree, the\n * `_$notifyConnectionChanged` API is patched onto ChildParts as a directive\n * climbs the parent tree, which is called by the core when clearing a part if\n * it exists. When called, that method iterates over the sparse tree of\n * Set<DisconnectableChildren> built up by AsyncDirectives, and calls\n * `_$notifyDirectiveConnectionChanged` on any directives that are encountered\n * in that tree, running the required callbacks.\n *\n * A given \"logical tree\" of lit-html data-structures might look like this:\n *\n *  ChildPart(N1) _$dC=[D2,T3]\n *   ._directive\n *     AsyncDirective(D2)\n *   ._value // user value was TemplateResult\n *     TemplateInstance(T3) _$dC=[A4,A6,N10,N12]\n *      ._$parts[]\n *        AttributePart(A4) _$dC=[D5]\n *         ._directives[]\n *           AsyncDirective(D5)\n *        AttributePart(A6) _$dC=[D7,D8]\n *         ._directives[]\n *           AsyncDirective(D7)\n *           Directive(D8) _$dC=[D9]\n *            ._directive\n *              AsyncDirective(D9)\n *        ChildPart(N10) _$dC=[D11]\n *         ._directive\n *           AsyncDirective(D11)\n *         ._value\n *           string\n *        ChildPart(N12) _$dC=[D13,N14,N16]\n *         ._directive\n *           AsyncDirective(D13)\n *         ._value // user value was iterable\n *           Array<ChildPart>\n *             ChildPart(N14) _$dC=[D15]\n *              ._value\n *                string\n *             ChildPart(N16) _$dC=[D17,T18]\n *              ._directive\n *                AsyncDirective(D17)\n *              ._value // user value was TemplateResult\n *                TemplateInstance(T18) _$dC=[A19,A21,N25]\n *                 ._$parts[]\n *                   AttributePart(A19) _$dC=[D20]\n *                    ._directives[]\n *                      AsyncDirective(D20)\n *                   AttributePart(A21) _$dC=[22,23]\n *                    ._directives[]\n *                      AsyncDirective(D22)\n *                      Directive(D23) _$dC=[D24]\n *                       ._directive\n *                         AsyncDirective(D24)\n *                   ChildPart(N25) _$dC=[D26]\n *                    ._directive\n *                      AsyncDirective(D26)\n *                    ._value\n *                      string\n *\n * Example 1: The directive in ChildPart(N12) updates and returns `nothing`. The\n * ChildPart will _clear() itself, and so we need to disconnect the \"value\" of\n * the ChildPart (but not its directive). In this case, when `_clear()` calls\n * `_$notifyConnectionChanged()`, we don't iterate all of the\n * _$disconnectableChildren, rather we do a value-specific disconnection: i.e.\n * since the _value was an Array<ChildPart> (because an iterable had been\n * committed), we iterate the array of ChildParts (N14, N16) and run\n * `setConnected` on them (which does recurse down the full tree of\n * `_$disconnectableChildren` below it, and also removes N14 and N16 from N12's\n * `_$disconnectableChildren`). Once the values have been disconnected, we then\n * check whether the ChildPart(N12)'s list of `_$disconnectableChildren` is empty\n * (and would remove it from its parent TemplateInstance(T3) if so), but since\n * it would still contain its directive D13, it stays in the disconnectable\n * tree.\n *\n * Example 2: In the course of Example 1, `setConnected` will reach\n * ChildPart(N16); in this case the entire part is being disconnected, so we\n * simply iterate all of N16's `_$disconnectableChildren` (D17,T18) and\n * recursively run `setConnected` on them. Note that we only remove children\n * from `_$disconnectableChildren` for the top-level values being disconnected\n * on a clear; doing this bookkeeping lower in the tree is wasteful since it's\n * all being thrown away.\n *\n * Example 3: If the LitElement containing the entire tree above becomes\n * disconnected, it will run `childPart.setConnected()` (which calls\n * `childPart._$notifyConnectionChanged()` if it exists); in this case, we\n * recursively run `setConnected()` over the entire tree, without removing any\n * children from `_$disconnectableChildren`, since this tree is required to\n * re-connect the tree, which does the same operation, simply passing\n * `isConnected: true` down the tree, signaling which callback to run.\n */\n\nimport {AttributePart, ChildPart, Disconnectable, Part} from './lit-html.js';\nimport {isSingleExpression} from './directive-helpers.js';\nimport {Directive, PartInfo, PartType} from './directive.js';\nexport * from './directive.js';\n\nconst DEV_MODE = true;\n\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (\n  parent: Disconnectable,\n  isConnected: boolean\n): boolean => {\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (obj as AsyncDirective)['_$notifyDirectiveConnectionChanged']?.(\n      isConnected,\n      false\n    );\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj: Disconnectable) => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren!;\n    children.delete(obj);\n    obj = parent;\n  } while (children?.size === 0);\n};\n\nconst addDisconnectableToParent = (obj: Disconnectable) => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; (parent = obj._$parent); obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(this: ChildPart, newParent: Disconnectable) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(\n  this: ChildPart,\n  isConnected: boolean,\n  isClearingValue = false,\n  fromPartIndex = 0\n) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value as Disconnectable, false);\n      removeDisconnectableFromParent(value as Disconnectable);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj: Disconnectable) => {\n  if ((obj as ChildPart).type == PartType.CHILD) {\n    (obj as ChildPart)._$notifyConnectionChanged ??=\n      notifyChildPartConnectedChanged;\n    (obj as ChildPart)._$reparentDisconnectables ??= reparentDisconnectables;\n  }\n};\n\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport abstract class AsyncDirective extends Directive {\n  // As opposed to other Disconnectables, AsyncDirectives always get notified\n  // when the RootPart connection changes, so the public `isConnected`\n  // is a locally stored variable initialized via its part's getter and synced\n  // via `_$notifyDirectiveConnectionChanged`. This is cheaper than using\n  // the _$isConnected getter, which has to look back up the tree each time.\n  /**\n   * The connection state for this Directive.\n   */\n  isConnected!: boolean;\n\n  // @internal\n  override _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  override _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  override ['_$notifyDirectiveConnectionChanged'](\n    isConnected: boolean,\n    isClearingDirective = true\n  ) {\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        this.reconnected?.();\n      } else {\n        this.disconnected?.();\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value: unknown) {\n    if (isSingleExpression(this.__part as unknown as PartInfo)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...(this.__part._$committedValue as Array<unknown>)];\n      newValues[this.__attributeIndex!] = value;\n      (this.__part as AttributePart)._$setValue(newValues, this, 0);\n    }\n  }\n\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  protected disconnected() {}\n  protected reconnected() {}\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"],"names":["LitVirtualizer","_LitElement","_this","_classCallCheck","items","renderItem","defaultRenderItem","keyFunction","defaultKeyFunction","layout","scroller","_inherits","_createClass","key","value","this","html","_templateObject","_taggedTemplateLiteral","virtualize","index","_this$virtualizerRef","virtualizerRef","element","get","_this$virtualizerRef2","layoutComplete","_this$element","position","arguments","length","undefined","scrollIntoView","block","LitElement","__decorate","property","attribute","reflect","type","Boolean","ScrollerController","_ScrollerShim","client","_callSuper","_clients","Set","_retarget","_end","__destination","correctingScrollError","_checkForArrival","bind","_updateManagedScrollTo","scrollTo","scrollBy","node","_node","_originalScrollTo","_originalScrollBy","_originalScroll","scroll","_attach","_destination","p1","p2","options","left","top","_scrollTo","scrollTop","scrollLeft","_element","window","retarget","end","behavior","_setDestination","_resetScrollState","_nativeScrollTo","Math","max","min","maxScrollTop","maxScrollLeft","coordinates","_this2","requestAnimationFrame","_this$_destination","topDiff","abs","leftDiff","delete","size","removeEventListener","add","addEventListener","ScrollerShim","document","scrollingElement","documentElement","scrollY","scrollX","scrollHeight","scrollWidth","getBoundingClientRect","height","innerHeight","width","innerWidth","viewportHeight","viewportWidth","_ResizeObserver","ResizeObserver","DefaultLayoutConstructor","Symbol","SIZER_ATTRIBUTE","Virtualizer","config","_benchmarkStart","_layout","_clippingAncestors","_scrollSize","_scrollError","_childrenPos","_childMeasurements","_toBeMeasured","Map","_rangeChanged","_itemsChanged","_visibilityChanged","_scrollerController","_isScroller","_sizer","_hostElementRO","_childrenRO","_mutationObserver","_scrollEventListeners","_scrollEventListenerOptions","passive","_loadListener","_childLoaded","_scrollIntoViewTarget","_updateScrollIntoViewCoordinates","_items","_first","_last","_firstVisible","_lastVisible","_scheduled","WeakSet","_measureCallback","_measureChildOverride","_layoutCompletePromise","_layoutCompleteResolver","_layoutCompleteRejecter","_pendingLayoutComplete","_layoutInitialized","_connected","Error","hostElement","_init","set","Array","isArray","_schedule","_updateLayout","_initHostElement","layoutConfig","_initLayout","MutationObserver","_finishDOMUpdate","_hostElementSizeChanged","_childrenSizeChanged","_hostElement","_applyVirtualizerStyles","_initObservers","includeSelf","getClippingAncestors","_observeAndListen","observe","childList","push","forEach","ancestor","_children","child","target","_this$_scrollerContro","_this$_mutationObserv","_this$_hostElementRO","_this$_childrenRO","_this3","detach","disconnect","_rejectLayoutCompletePromise","style","display","contain","overflow","minHeight","sizer","querySelector","concat","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","textContent","_updateLayoutConfig","_asyncToGenerator","_regenerator","m","_callee","Ctor","w","_context","n","a","_x","apply","_initLayout2","_callee2","copy","_this4","_context2","v","FlowLayout","message","_handleLayoutMessage","measureChildren","updateItemSizes","listenForChildLoadEvents","_x2","performance","now","_this5","timeElapsed","virtualizationTime","getEntriesByName","filter","e","startTime","reduce","t","duration","mm","children","fn","_measureChild","i","idx","has","call","clear","el","_element$getBoundingC","marginTop","getMarginValue","getComputedStyle","marginRight","marginBottom","marginLeft","_schedule2","_callee3","method","_context3","Promise","resolve","_x3","_updateDOM2","_callee4","state","_context4","scrollSize","_adjustRange","range","childPositions","scrollError","_notifyVisibility","_notifyRange","_x4","_this6","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","mark","_updateView","reflowIfNeeded","measure","console","warn","_this$_layout","unpin","event","currentTarget","includes","_handleScrollEvent","_updateDOM","firstVisible","lastVisible","dispatchEvent","UnpinnedEvent","arr","next","firstElementChild","hasAttribute","nextElementSibling","_this$_scrollerContro2","bottom","right","hostElementBounds","ancestorBounds","map","unshift","_step","_iterator","_createForOfIteratorHelper","s","done","bounds","err","f","scrollingElementBounds","offsetWithinScroller","totalScrollSize","viewportSize","viewportScroll","h","_getSizer","transform","minWidth","pos","_this7","_ref","xOffset","yOffset","boxSizing","_adjustRange2","_callee5","_context5","first","last","_x5","_this$_scrollerContro3","_this$_scrollError","correctScrollError","_this$_items","_this8","Infinity","_scrollElementIntoView","_this9","getScrollIntoViewCoordinates","managedScrollTo","pin","RangeChangedEvent","VisibilityChangedEvent","_this0","reject","reason","_resetLayoutCompleteState","_this1","_resolveLayoutCompletePromise","changes","_this$_layout2","_step2","_iterator2","change","contentRect","_measureChildren","_scheduleLayoutComplete","float","parseFloat","NaN","Number","isNaN","getParentElement","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","getElementAncestors","ancestors","parent","foundFixed","_Event","eventName","bubbles","_wrapNativeSuper","Event","_Event2","_Event3","customElements","define","item","JSON","stringify","VirtualizeDirective","_AsyncDirective","part","_virtualizer","_renderItem","_keyFunction","PartType","_setFunctions","itemsToRender","repeat","_slicedToArray","itemsChanged","_updateVirtualizerConfig","_initialize","noChange","render","_updateVirtualizerConfig2","updateLayoutConfig","_makeVirtualizer","disconnected","connected","setValue","_this$_virtualizer","_this$_virtualizer2","AsyncDirective","directive","_$AN","_i$_$AO","_$AO","o","_e","_$AM","r","c","_$AH","_i$_$AP","_i$_$AQ","_$AP","_$AQ","_t2","_superPropGet","isConnected","_$AU","_this$reconnected","_this$disconnected","reconnected","_$Ct","_$AI","_toConsumableArray","_$Ci","l","_t","_class","values","keys","dt","_this$ut","_ref2","d","_this$dt","p","ut","y","x","j","k","u"],"mappings":";+TAmBO,IAAMA,EAA4B,SAAAC,GAAzC,SAAAD,IAAA,IAAAE,EAcmB,OAdnBC,EAAAA,EAAAA,GAAA,KAAAH,iCAEEI,MAAa,GAGbF,EAAAG,WAAoCC,EAAAA,GAGpCJ,EAAAK,YAAwBC,EAAAA,GAGxBN,EAAAO,OAA4B,CAAC,EAG7BP,EAAAQ,UAAW,EAAMR,CAmCnB,CAAC,OAAAS,EAAAA,EAAAA,GAAAX,EAAAC,IAAAW,EAAAA,EAAAA,GAAAZ,EAAA,EAAAa,IAAA,mBAAAC,MAjCC,WACE,OAAOC,IACT,GAAC,CAAAF,IAAA,SAAAC,MAED,WACE,IAAOV,EAAoDW,KAApDX,MAAOC,EAA6CU,KAA7CV,WAAYE,EAAiCQ,KAAjCR,YAAaE,EAAoBM,KAApBN,OAAQC,EAAYK,KAAZL,SAC/C,OAAOM,EAAAA,EAAAA,IAAIC,IAAAA,GAAAC,EAAAA,EAAAA,GAAA,WAAAC,EAAAA,EAAAA,IAAa,CACtBf,MAAAA,EACAC,WAAAA,EACAE,YAAAA,EACAE,OAAAA,EACAC,SAAAA,IAEJ,GAAC,CAAAG,IAAA,UAAAC,MAED,SAAQM,GAAa,IAAAC,EACnB,OAAuD,QAAvDA,EAAQN,KAAgCO,EAAAA,WAAe,IAAAD,OAAA,EAA/CA,EAAiDE,QAAQH,EACnE,GAAC,CAAAP,IAAA,iBAAAW,IAED,WAAkB,IAAAC,EAChB,OAAuD,QAAvDA,EAAQV,KAAgCO,EAAAA,WAAe,IAAAG,OAAA,EAA/CA,EAAiDC,cAC3D,GAEA,CAAAb,IAAA,gBAAAC,MAGG,SAAAM,GAAA,IAAAO,EAAAC,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,WAKkB,QAAnBF,EAAAZ,KAAKQ,QAAQH,UAAM,IAAAO,GAAnBA,EAAqBK,eAAe,CAACC,MAAOL,GAC9C,IAAC,CAhDsC,CAAQM,EAAAA,KAE/CC,EAAAA,EAAAA,YAAA,EADCC,EAAAA,EAAAA,GAAS,CAACC,WAAW,KAAO,6BAI7BF,EAAAA,EAAAA,YAAA,EADCC,EAAAA,EAAAA,MAAU,kCAIXD,EAAAA,EAAAA,YAAA,EADCC,EAAAA,EAAAA,MAAU,mCAIXD,EAAAA,EAAAA,YAAA,EADCC,EAAAA,EAAAA,GAAS,CAACC,WAAW,KAAO,8BAI7BF,EAAAA,EAAAA,YAAA,EADCC,EAAAA,EAAAA,GAAS,CAACE,SAAS,EAAMC,KAAMC,WAAS,2JCmC9BC,+GAAmB,SAAAC,GAe9B,SAAAD,EAAYE,EAAiBpB,GAAiB,IAAArB,GAAAC,EAAAA,EAAAA,GAAA,KAAAsC,IAC5CvC,GAAA0C,EAAAA,EAAAA,GAAA,KAAAH,EAAA,CAAMlB,KANAsB,SAAW,IAAIC,IACf5C,EAAA6C,UAA8C,KAC9C7C,EAAA8C,KAAoC,KACpC9C,EAAA+C,cAA2C,KAkB5C/C,EAAAgD,uBAAwB,EAb7BhD,EAAKiD,iBAAmBjD,EAAKiD,iBAAiBC,KAAIlD,GAClDA,EAAKmD,uBAAyBnD,EAAKmD,uBAAuBD,KAAIlD,GAC9DA,EAAKoD,SAAWpD,EAAKoD,SAASF,KAAIlD,GAClCA,EAAKqD,SAAWrD,EAAKqD,SAASH,KAAIlD,GAElC,IAAMsD,EAAOtD,EAAKuD,MAKG,OAHrBvD,EAAKwD,kBAAoBF,EAAKF,SAC9BpD,EAAKyD,kBAAoBH,EAAKD,SAC9BrD,EAAK0D,gBAAkBJ,EAAKK,OAC5B3D,EAAK4D,QAAQnB,GAAQzC,CACvB,CAAC,OAAAS,EAAAA,EAAAA,GAAA8B,EAAAC,IAAA9B,EAAAA,EAAAA,GAAA6B,EAAA,EAAA5B,IAAA,eAAAW,IAID,WACE,OAAOT,KAAKkC,aACd,GAAC,CAAApC,IAAA,YAAAW,IAED,WACE,OAA6B,OAAtBT,KAAKgD,YACd,GAAC,CAAAlD,IAAA,WAAAC,MAKM,SAASkD,EAA8BC,GAC5C,IAAMC,EACU,iBAAPF,GAAiC,iBAAPC,EAAe,CAC3CE,KAAMH,EAAII,IAAKH,GAAGD,EAEzBjD,KAAKsD,UAAUH,EACjB,GAAC,CAAArD,IAAA,WAAAC,MAKM,SAASkD,EAA8BC,GAC5C,IAAMC,EACU,iBAAPF,GAAiC,iBAAPC,EAAe,CAC3CE,KAAMH,EAAII,IAAKH,GAAGD,OAELjC,IAAhBmC,EAAQE,MACVF,EAAQE,KAAOrD,KAAKuD,gBAEDvC,IAAjBmC,EAAQC,OACVD,EAAQC,MAAQpD,KAAKwD,YAEvBxD,KAAKsD,UAAUH,EACjB,GAAC,CAAArD,IAAA,kBAAAC,MAEO,SAAgBoD,GACtBnD,KAAK2C,kBAAmBN,KAAKrC,KAAKyD,UAAYC,OAA9C1D,CAAsDmD,EACxD,GAAC,CAAArD,IAAA,YAAAC,MAEO,SACNoD,GAEoC,IADpCQ,EAAA7C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAA0C,KAC1C8C,EAAA9C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAgC,KAEd,OAAdd,KAAKiC,MACPjC,KAAKiC,OAEkB,WAArBkB,EAAQU,UACV7D,KAAK8D,gBAAgBX,GACrBnD,KAAKgC,UAAY2B,EACjB3D,KAAKiC,KAAO2B,GAEZ5D,KAAK+D,oBAEP/D,KAAKgE,gBAAgBb,EACvB,GAAC,CAAArD,IAAA,kBAAAC,MAEO,SAAgBoD,GACtB,IAAKE,EAAaF,EAAbE,IAAKD,EAAQD,EAARC,KASV,OARAC,OAAGrC,IAAAqC,OAAArC,EAAAiD,KAAAC,IAAA,EAAAD,KAAAE,IAAAd,EAAA,KAAAe,eAIHhB,OAAIpC,IAAAoC,OAAApC,EAAAiD,KAAAC,IAAA,EAAAD,KAAAE,IAAAf,EAAA,KAAAiB,iBAKoB,OAAtBrE,KAAKgD,cAAqBI,IAAA,KAAAJ,aAAAI,MAAAC,IAAA,KAAAL,aAAAK,OAM5BrD,KAAKkC,cAAgB,CAACmB,IAAAA,EAAKD,KAAAA,EAAMS,SAAU,WACpC,EACT,GAAC,CAAA/D,IAAA,oBAAAC,MAEO,WACNC,KAAKkC,cAAgB,KACrBlC,KAAKgC,UAAY,KACjBhC,KAAKiC,KAAO,IACd,GAAC,CAAAnC,IAAA,yBAAAC,MAEO,SAAuBuE,GACzBtE,KAAKgD,cACHhD,KAAK8D,gBAAgBQ,IACvBtE,KAAKgE,gBAAgBhE,KAAKgD,aAGhC,GAAC,CAAAlD,IAAA,kBAAAC,MAEM,SACLoD,EACAQ,EACAC,GAGA,OADA5D,KAAKsD,UAAUH,EAASQ,EAAUC,GAC3B5D,KAAKsC,sBACd,GAAC,CAAAxC,IAAA,qBAAAC,MAEM,SAAmBuE,GAAgC,IAAAC,EAAA,KACxDvE,KAAKmC,uBAAwB,EAC7BqC,uBAAsB,kBAAGA,uBACvB,kBAAsBD,EAAOpC,uBAAK,CAAwB,OAG5DnC,KAAKgE,gBAAgBM,GAGjBtE,KAAKgC,WACPhC,KAAK8D,gBAAgB9D,KAAKgC,aAGxBhC,KAAKgD,cACPhD,KAAKgE,gBAAgBhE,KAAKgD,aAE9B,GAAC,CAAAlD,IAAA,mBAAAC,MAEO,WACN,GAA0B,OAAtBC,KAAKgD,aAAuB,CAC9B,IAAOO,EAAyBvD,KAAzBuD,UAAWC,EAAcxD,KAAdwD,WAClBiB,EAAkBzE,KAAKgD,aAAlBK,EAAGoB,EAAHpB,IAAKD,EAAIqB,EAAJrB,KACVC,EAAMY,KAAKE,IAAId,GAAO,EAAGrD,KAAKoE,cAC9BhB,EAAOa,KAAKE,IAAIf,GAAQ,EAAGpD,KAAKqE,eAChC,IAAMK,EAAUT,KAAKU,IAAItB,EAAME,GACzBqB,EAAWX,KAAKU,IAAIvB,EAAOI,GAE7BkB,EAAU,GAAKE,EAAW,IACxB5E,KAAKiC,MACPjC,KAAKiC,OAEPjC,KAAK+D,oBAET,CACF,GAAC,CAAAjE,IAAA,SAAAC,MAEM,SAAO6B,GAaZ,OAZA5B,KAAK8B,SAAS+C,OAAOjD,GAKlB,SAAAE,SAAAgD,OAED9E,KAAK0C,MAAMH,SAAWvC,KAAK2C,kBAC3B3C,KAAK0C,MAAMF,SAAWxC,KAAK4C,kBAC3B5C,KAAK0C,MAAMI,OAAS9C,KAAK6C,gBACzB7C,KAAK0C,MAAMqC,oBAAoB,SAAU/E,KAAKoC,mBAEzC,IACT,GAAC,CAAAtC,IAAA,UAAAC,MAEO,SAAQ6B,GACd5B,KAAK8B,SAASkD,IAAIpD,GAKf,SAAAE,SAAAgD,OAED9E,KAAK0C,MAAMH,SAAWvC,KAAKuC,SAC3BvC,KAAK0C,MAAMF,SAAWxC,KAAKwC,SAC3BxC,KAAK0C,MAAMI,OAAS9C,KAAKuC,SACzBvC,KAAK0C,MAAMuC,iBAAiB,SAAUjF,KAAKoC,kBAE/C,IAAC,CAxM6B,CA/D7B,WAkBA,OAAAvC,EAAAA,EAAAA,IAND,SAAAqF,EAAY1E,IAAiBpB,EAAAA,EAAAA,GAAA,KAAA8F,GAFnB,KAAAzB,SAA8B,KAGtC,IAAMhB,EAAOjC,QAAAA,EAAWkD,OACxB1D,KAAK0C,MAAQD,EACTjC,IACFR,KAAKyD,SAAWjD,EAEpB,GAAC,EAAAV,IAAA,UAAAW,IAED,WACE,OAAO,KACDgD,UAAS0B,SAAYC,kBAAiBD,SAAYE,eAE1D,GAAC,CAAAvF,IAAA,YAAAW,IAED,WACE,OAAOT,KAAKQ,QAAQ+C,WAAaG,OAAO4B,OAC1C,GAAC,CAAAxF,IAAA,aAAAW,IAED,WACE,OAAOT,KAAKQ,QAAQgD,YAAcE,OAAO6B,OAC3C,GAAC,CAAAzF,IAAA,eAAAW,IAED,WACE,OAAOT,KAAKQ,QAAQgF,YACtB,GAAC,CAAA1F,IAAA,cAAAW,IAED,WACE,OAAOT,KAAKQ,QAAQiF,WACtB,GAAC,CAAA3F,IAAA,iBAAAW,IAED,WACE,OAAOT,KAAKyD,SAAQ,KAAAA,SAAAiC,wBAAAC,OAAAjC,OAAAkC,WAGtB,GAAC,CAAA9F,IAAA,gBAAAW,IAED,WACE,OAAOT,KAAKyD,SAAQ,KAAAA,SAAAiC,wBAAAG,MAAAnC,OAAAoC,UAGtB,GAAC,CAAAhG,IAAA,eAAAW,IAED,WACE,OAAOT,KAAKwF,aAAexF,KAAK+F,cAClC,GAAC,CAAAjG,IAAA,gBAAAW,IAED,WACE,OAAOT,KAAKyF,YAAczF,KAAKgG,aACjC,IAAC,CA5DA,qeCgCH,IAAIC,EACgB,oBAAXvC,OAAyBA,OAAOwC,oBAAiBlF,EAUnD,IA6CHmF,EA7CS5F,EAAiB6F,OAAO,kBAC/BC,EAAkB,oBAqDrBC,EAAA,WAsJA,OAAAzG,EAAAA,EAAAA,IAbD,SAAAyG,EAAYC,GACV,IADmCnH,EAAAA,EAAAA,GAAA,KAAAkH,GAvI7B,KAAAE,gBAAiC,KAEjC,KAAAC,QAAyB,KAEzB,KAAAC,mBAAoC,GAKzC,KAAAC,YAAA,KAMA,KAAAC,aAAA,KAKA,KAAAC,aAAA,KAIK,KAAAC,mBAA+C,KAE/C,KAAAC,cAAgB,IAAIC,IAEpB,KAAAC,eAAgB,EAEhB,KAAAC,eAAgB,EAEhB,KAAAC,oBAAqB,EAOrB,KAAAC,oBAAiD,KAEjD,KAAAC,aAAc,EAEd,KAAAC,OAA6B,KAIlC,KAAAC,eAAA,KAKA,KAAAC,YAAA,KAGK,KAAAC,kBAA6C,KAE7C,KAAAC,sBAA8C,GAC9C,KAAAC,4BAAuD,CAC7DC,SAAS,GAKH,KAAAC,cAAgB7H,KAAK8H,aAAazF,KAAKrC,MAM5C,KAAA+H,sBAAA,KAGK,KAAAC,iCAEG,KAIR,KAAAC,OAAA,GAMA,KAAAC,QAAA,EAKA,KAAAC,OAAA,EAKA,KAAAC,eAAA,EAKA,KAAAC,cAAA,EAGO,KAAAC,WAAa,IAAIC,QAMxB,KAAAC,iBAAA,KAIO,KAAAC,sBAAqD,KAI5D,KAAAC,uBAAA,KAEK,KAAAC,wBAA2C,KAC3C,KAAAC,wBAA2C,KAC3C,KAAAC,uBAAwC,KAM7C,KAAAC,mBAAA,KAKA,KAAAC,YAAA,GAIIxC,EACH,MAAM,IAAIyC,MACR,2DAGJ,IAAIzC,EAAO0C,YAGT,MAAM,IAAID,MACR,iEAHFhJ,KAAKkJ,MAAM3C,EAMf,GAAC,EAAAzG,IAAA,QAAAqJ,IAED,SAAU9J,GACJ+J,MAAMC,QAAQhK,IAAUA,IAAUW,KAAKiI,SACzCjI,KAAKkH,eAAgB,EACrBlH,KAAKiI,OAAS5I,EACdW,KAAKsJ,UAAUtJ,KAAKuJ,eAExB,GAAC,CAAAzJ,IAAA,QAAAC,MAED,SAAMwG,GACJvG,KAAKqH,cAAgBd,EAAO5G,SAC5BK,KAAKwJ,iBAAiBjD,GAItB,IAAMkD,EAAelD,EAAO7G,QAAW,CAAC,EAGxCM,KAAK8I,mBAAqB9I,KAAK0J,YAAYD,EAC7C,GAAC,CAAA3J,IAAA,iBAAAC,MAEO,WAAc,IAAAZ,EAAA,KACpBa,KAAKyH,kBAAoB,IAAIkC,iBAC3B3J,KAAK4J,iBAAiBvH,KAAKrC,OAE7BA,KAAKuH,eAAiB,IAAItB,GAAiB,kBAAG9G,EAC5C0K,yBAA4B,IAE9B7J,KAAKwH,YAAc,IAAIvB,EACrBjG,KAAK8J,qBAAqBzH,KAAKrC,MAEnC,GAAC,CAAAF,IAAA,mBAAAC,MAED,SAAiBwG,GACf,IAAM0C,EAAc,KAAKc,aAAaxD,EAAS0C,YAC/CjJ,KAAKgK,0BACLf,EAAY1I,GAAkBP,IAChC,GAAC,CAAAF,IAAA,YAAAC,MAED,WACEC,KAAKiK,iBACL,IAAMC,EAAclK,KAAKqH,YACzBrH,KAAK0G,mBAAqByD,EACxBnK,KAAK+J,aACLG,GAGFlK,KAAKoH,oBAAsB,IAAI1F,EAAAA,EAC7B1B,KACAA,KAAK0G,mBAAmB,IAG1B1G,KAAKsJ,UAAUtJ,KAAKuJ,eACpBvJ,KAAKoK,oBACLpK,KAAK+I,YAAa,CACpB,GAAC,CAAAjJ,IAAA,oBAAAC,MAED,WAAiB,IAAAwE,EAAA,KACfvE,KAAKyH,kBAAmB4C,QAAQrK,KAAK+J,aAAe,CAACO,WAAW,IAChEtK,KAAKuH,eAAgB8C,QAAQrK,KAAK+J,cAClC/J,KAAK0H,sBAAsB6C,KAAK7G,QAChCA,OAAOuB,iBAAiB,SAAUjF,KAAMA,KAAK2H,6BAC7C3H,KAAK0G,mBAAmB8D,SAAQ,SAACC,GAC/BA,EAASxF,iBACP,SACAV,EACAA,EAAKoD,6BAEPpD,EAAKmD,sBAAsB6C,KAAKE,GAChClG,EAAKgD,eAAgB8C,QAAQI,EAC/B,IACAzK,KAAKuH,eAAgB8C,QAAQrK,KAAKoH,oBAAqB5G,SACvDR,KAAK0K,UAAUF,SAAQ,SAACG,GAAK,OAAEpG,EAAGiD,YAAK6C,QAAaM,EAAQ,IAC5D3K,KAAK0H,sBAAsB8C,SAAQ,SAACI,GAAM,OAAEA,EAC1C3F,iBAAO,SAAyBV,EAAMA,EAAEoD,4BAAK,GAEjD,GAAC,CAAA7H,IAAA,eAAAC,MAED,WAAY,IAAA8K,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,KACVjL,KAAK0H,sBAAsB8C,SAAQ,SAACI,GAAM,OAAEA,EAC1C7F,oBAAO,SACGkG,EACJA,EACJtD,4BAAK,IAGT3H,KAAK0H,sBAAwB,GAC7B1H,KAAK0G,mBAAqB,GACF,QAAxBmE,EAAA7K,KAAKoH,2BAAmB,IAAAyD,GAAxBA,EAA0BK,OAAOlL,MACjCA,KAAKoH,oBAAsB,KACL,QAAtB0D,EAAA9K,KAAKyH,yBAAiB,IAAAqD,GAAtBA,EAAwBK,aACxBnL,KAAKyH,kBAAoB,KACN,QAAnBsD,EAAA/K,KAAKuH,sBAAc,IAAAwD,GAAnBA,EAAqBI,aACrBnL,KAAKuH,eAAiB,KACN,QAAhByD,EAAAhL,KAAKwH,mBAAW,IAAAwD,GAAhBA,EAAkBG,aAClBnL,KAAKwH,YAAc,KACnBxH,KAAKoL,6BAA6B,gBAClCpL,KAAK+I,YAAa,CACpB,GAAC,CAAAjJ,IAAA,0BAAAC,MAEO,WACN,IAKMsL,EALcrL,KAAK+J,aAKCsB,MAC1BA,EAAMC,QAAUD,EAAMC,SAAW,QACjCD,EAAMxK,SAAWwK,EAAMxK,UAAY,WACnCwK,EAAME,QAAUF,EAAME,SAAW,cAE7BvL,KAAKqH,cACPgE,EAAMG,SAAWH,EAAMG,UAAY,OACnCH,EAAMI,UAAYJ,EAAMI,WAAa,QAEzC,GAAC,CAAA3L,IAAA,YAAAC,MAED,WACE,IAAMkJ,EAAcjJ,KAAK+J,aACzB,IAAK/J,KAAKsH,OAAQ,CAGhB,IAAIoE,EAAQzC,EAAY0C,cAAc,IAADC,OAC/BvF,EAAe,MAEhBqF,KACHA,EAAQvG,SAAS0G,cAAc,QACzBC,aAAazF,EAAiB,IACpC4C,EAAY8C,YAAYL,IAI1BM,OAAOC,OAAOP,EAAML,MAAO,CACzBxK,SAAU,WACVqL,OAAQ,aACRC,QAAS,EACTC,WAAY,SACZC,SAAU,QAEZX,EAAMY,YAAc,SACpBZ,EAAMI,aAAazF,EAAiB,IACpCrG,KAAKsH,OAASoE,CAChB,CACA,OAAO1L,KAAKsH,MACd,GAAC,CAAAxH,IAAA,qBAAAC,OAAAwM,GAAAC,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,GAED,SAAAC,EAAyBlD,GAA+B,IAAAmD,EAAArG,EAAA,OAAAkG,EAAAA,EAAAA,KAAAI,GAAA,SAAAC,GAAA,cAAAA,EAAAC,GAAA,cAAAD,EAAAC,EAAA,EAIhD/M,KAAK8I,mBAAkB,OAMH,KACN,mBANd8D,EACFnD,EAAiCjI,MAInC2E,IACgCnG,KAAKyG,mBAAmBmG,GAAI,CAAAE,EAAAC,EAAA,QAU5D,cATMxG,EAAMyF,OAAAC,OAAA,GAAQxC,IAGNjI,KACdxB,KAAKyG,QAAQF,OAASA,EAKtBuG,EAAAE,EAAA,GACO,GAAI,cAAAF,EAAAE,EAAA,GAEN,GAAK,GAAAL,EAAA,UACb,SAzBuBM,GAAA,OAAAV,EAAAW,MAAC,KAADpM,UAAA,KAAAhB,IAAA,cAAAC,OAAAoN,GAAAX,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,GA2BhB,SAAAU,EAAkB3D,GAA+B,IAAAlD,EAAAqG,EAAAS,EAAAC,EAAA,YAAAb,EAAAA,EAAAA,KAAAI,GAAA,SAAAU,GAAA,cAAAA,EAAAR,GAAA,OAiBtD,GAdqD,mBAA1CtD,EAAiCjI,MAG3CoL,EAAQnD,EAAiCjI,YAEnC6L,EAAIrB,OAAAC,OAAA,GAAQxC,IAGNjI,KACZ+E,EAAS8G,GAIT9G,EAASkD,OAGEzI,IAAT4L,EAAkB,CAAAW,EAAAR,EAAA,eAAAQ,EAAAR,EAAA,EAEqB,iCAA2B,OAApE5G,EAA2ByG,EAAIW,EAAAC,EAAsCC,WAAA,OAIvEzN,KAAKyG,QAAU,IAAImG,GACjB,SAACc,GAA0B,OAAEJ,EAAGK,qBAAKD,EAAqB,GAAQnH,GAKlEvG,KAAKyG,QAAQmH,iBAAe,wBAAAnH,QAAAoH,kBAGgB,mBAAjC7N,KAAKyG,QAAQmH,kBACtB5N,KAAKyI,sBAAwBzI,KAAKyG,QAAQmH,iBAE5C5N,KAAKwI,iBAAmBxI,KAAKyG,QAAQoH,gBAAgBxL,KAAKrC,KAAKyG,UAG7DzG,KAAKyG,QAAQqH,0BACf9N,KAAK+J,aAAc9E,iBAAiB,OAAQjF,KAAK6H,eAAe,GAGlE7H,KAAKsJ,UAAUtJ,KAAKuJ,eAAe,cAAAgE,EAAAP,EAAA,MAAAI,EAAA,UACpC,SA7CwBW,GAAA,OAAAZ,EAAAD,MAAC,KAADpM,UAAA,IAgDzB,CAAAhB,IAAA,oBAAAC,MACA,WAC+B,OAAzBC,KAAKwG,kBACPxG,KAAKwG,gBAAkB9C,OAAOsK,YAAYC,MAE9C,GAAC,CAAAnO,IAAA,mBAAAC,MAED,WAAgB,IAAAmO,EAAA,KACd,GAA6B,OAAzBlO,KAAKwG,gBAA0B,CACjC,IAAMyH,EAAMvK,OAAOsK,YAAYC,MACzBE,EAAcF,EAAMjO,KAAKwG,gBAKzB4H,EAJUJ,YAAYK,iBAC1B,kBACA,WAEgCC,QAAA,SAAAC,GAAA,OAAAA,EAAAC,WAAAN,EAAA1H,iBAAA+H,EAAAC,UAAAP,CAAA,IAAAQ,QAAA,SAAAC,EAAAhC,GAAA,OAAAgC,EAAAhC,EAAAiC,QAAA,MAMlC,OADA3O,KAAKwG,gBAAkB,KAChB,CAAC2H,YAAAA,EAAaC,mBAAAA,EACvB,CACA,OAAO,IACT,GAAC,CAAAtO,IAAA,mBAAAC,MAEO,WAIN,IAHA,IAAM6O,EAAwB,CAAC,EACzBC,EAAW7O,KAAK0K,UAChBoE,EAAK9O,KAAKyI,uBAAyBzI,KAAK+O,cACzCC,EAAK,EAAIA,EAAGH,EAAW9N,OAAOiO,IAAK,CACtC,IAAMrE,EAAQkE,EAASG,GACjBC,EAAMjP,KAAKkI,OAAS8G,GACtBhP,KAAKkH,eAAiBlH,KAAK+G,cAAcmI,IAAIvE,MAC/CiE,EAAGK,GAAOH,EAAGK,KAAKnP,KAAM2K,EAAO3K,KAAKiI,OAAOgH,IAE/C,CACAjP,KAAK8G,mBAAqB8H,EAC1B5O,KAAKsJ,UAAUtJ,KAAKuJ,eACpBvJ,KAAK+G,cAAcqI,OACrB,GAEA,CAAAtP,IAAA,gBAAAC,MAEG,SAAAS,GAID,IAwYgB6O,EACZhE,EAzYJiE,EAAwB9O,EAAQkF,wBAAzBG,EAAKyJ,EAALzJ,MAAOF,EAAM2J,EAAN3J,OACd,OAAOqG,OAAOC,OAAO,CAACpG,MAAAA,EAAOF,OAAAA,IAuYb0J,EAvYiC7O,EAyY5C,CACL+O,UAAWC,GAFPnE,EAAQ3H,OAAO+L,iBAAiBJ,IAEJE,WAChCG,YAAaF,EAAenE,EAAMqE,aAClCC,aAAcH,EAAenE,EAAMsE,cACnCC,WAAYJ,EAAenE,EAAMuE,cA5YnC,GAAC,CAAA9P,IAAA,YAAAC,OAAA8P,GAAArD,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,GAES,SAAAoD,EAAgBC,GAAgB,OAAAtD,EAAAA,EAAAA,KAAAI,GAAA,SAAAmD,GAAA,cAAAA,EAAAjD,GAAA,UACnC/M,KAAKsI,WAAW4G,IAAIa,GAAS,CAAFC,EAAAjD,EAAA,QACF,OAA5B/M,KAAKsI,WAAWtD,IAAI+K,GAAQC,EAAAjD,EAAA,EACtBkD,QAAQC,UAAS,OACvBlQ,KAAKsI,WAAWzD,OAAOkL,GACvBA,EAAOZ,KAAKnP,MAAM,cAAAgQ,EAAAhD,EAAA,MAAA8C,EAAA,UAErB,SAPwBK,GAAA,OAAAN,EAAA3C,MAAC,KAADpM,UAAA,KAAAhB,IAAA,aAAAC,OAAAqQ,GAAA5D,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,GASzB,SAAA2D,EAAiBC,GAA0B,IAAArJ,EAAAC,EAAA,OAAAuF,EAAAA,EAAAA,KAAAI,GAAA,SAAA0D,GAAA,cAAAA,EAAAxD,GAAA,OACzC/M,KAAK2G,YAAc2J,EAAME,WACzBxQ,KAAKyQ,aAAaH,EAAMI,OACxB1Q,KAAK6G,aAAeyJ,EAAMK,eAC1B3Q,KAAK4G,aAAe0J,EAAMM,aAAe,KAClC3J,EAAgCjH,KAAhCiH,cAAeC,EAAiBlH,KAAjBkH,cAClBlH,KAAKmH,qBACPnH,KAAK6Q,oBACL7Q,KAAKmH,oBAAqB,IAExBF,GAAiBC,KACnBlH,KAAK8Q,eACL9Q,KAAKiH,eAAgB,GAEvBjH,KAAK4J,mBAAmB,cAAA2G,EAAAvD,EAAA,MAAAqD,EAAA,UACzB,SAfeU,GAAA,OAAAX,EAAAlD,MAAC,KAADpM,UAAA,KAAAhB,IAAA,mBAAAC,MAiBhB,WAAgB,IAAAiR,EAAA,KACVhR,KAAK+I,aAEP/I,KAAK0K,UAAUF,SAAQ,SAACG,GAAK,OAAEqG,EAAGxJ,YAAK6C,QAAaM,EAAQ,IAC5D3K,KAAKiR,2BAA2BjR,KAAK6G,cACrC7G,KAAKkR,kBAAkBlR,KAAK6G,cAC5B7G,KAAKmR,iBAAiBnR,KAAK2G,aAC3B3G,KAAKoR,sBACDpR,KAAKwG,iBAAmB,SAAU9C,OAAOsK,aAC3CtK,OAAOsK,YAAYqD,KAAK,UAG9B,GAAC,CAAAvR,IAAA,gBAAAC,MAED,WACMC,KAAKyG,SAAWzG,KAAK+I,aACvB/I,KAAKyG,QAAQpH,MAAQW,KAAKiI,OAC1BjI,KAAKsR,cAC2B,OAA5BtR,KAAK8G,qBAEH9G,KAAKwI,kBACPxI,KAAKwI,iBAAiBxI,KAAK8G,oBAE7B9G,KAAK8G,mBAAqB,MAE5B9G,KAAKyG,QAAQ8K,iBACTvR,KAAKwG,iBAAmB,SAAU9C,OAAOsK,aAC3CtK,OAAOsK,YAAYqD,KAAK,UAG9B,GAAC,CAAAvR,IAAA,qBAAAC,MAEO,WACN,GAAIC,KAAKwG,iBAAmB,SAAU9C,OAAOsK,YAAa,CACxD,IACEtK,OAAOsK,YAAYwD,QAAQ,kBAAmB,WAAY,SAC5D,CAAE,MAADjD,GACCkD,QAAQC,KAAK,qCAAsCnD,EACrD,CACA7K,OAAOsK,YAAYqD,KAAK,WAC1B,CAC+D,IAAAM,GAAP,IAApD3R,KAAKoH,oBAAqBjF,wBAEhB,QAAZwP,EAAA3R,KAAKyG,eAAO,IAAAkL,GAAZA,EAAcC,SAEhB5R,KAAKsJ,UAAUtJ,KAAKuJ,cACtB,GAAC,CAAAzJ,IAAA,cAAAC,MAED,SAAY8R,GACV,GACO,WADPA,EAAarQ,MAGPqQ,EAAMC,gBAAkBpO,QAAM,KAAAgD,mBAAAqL,SAAAF,EAAAC,iBAG9B9R,KAAKgS,0BAIPP,QAAQC,KAAK,oBAAqBG,EAExC,GAAC,CAAA/R,IAAA,uBAAAC,MAED,SAAqB2N,GACE,iBAAjBA,EAAQlM,KACVxB,KAAKiS,WAAWvE,GACjB,sBAAAA,EAAAlM,MACCxB,KAAKoI,cAAgBsF,EAAQwE,aAC7BlS,KAAKqI,aAAeqF,EAAQyE,YAC5BnS,KAAK6Q,qBACN,aAAAnD,EAAAlM,MACCxB,KAAK+J,aAAcqI,cAAc,IAAIC,EAAAA,GAEzC,GAAC,CAAAvS,IAAA,YAAAW,IAED,WAGE,IAFA,IAAM6R,EAA0B,GAC5BC,EAAOvS,KAAK+J,aAAcyI,kBAC9BD,GACOA,EAAKE,aAAapM,IACrBiM,EAAI/H,KAAKgI,GAEXA,EAAOA,EAAKG,mBAEd,OAAOJ,CACT,GAAC,CAAAxS,IAAA,cAAAC,MAEO,WAAW,IAAA4S,EACX1J,EAAcjJ,KAAK+J,aACnB3E,EAA2C,QAA3BuN,EAAG3S,KAAKoH,2BAAmB,IAAAuL,OAAA,EAAxBA,EAA0BnS,QAC7Cd,EAASM,KAAKyG,QAEpB,GAAIwC,GAAe7D,GAAoB1F,EAAQ,CAC7C,IAAI2D,EAAKD,EAAMwP,EAAQC,EAEjBC,EAAoB7J,EAAYvD,wBAEtCrC,EAAM,EACND,EAAO,EACPwP,EAASlP,OAAOkC,YAChBiN,EAAQnP,OAAOoC,WAEf,IAAMiN,EAAiB/S,KAAK0G,mBAAmBsM,KAAI,SAACvI,GAAQ,OAAEA,EAC5D/E,uBAA8B,IAEhCqN,EAAeE,QAAQH,GAAmB,IAEPI,EAFOC,GAAAC,EAAAA,EAAAA,GAErBL,GAAc,IAAnC,IAAAI,EAAAE,MAAAH,EAAAC,EAAApG,KAAAuG,MAAmC,KAAxBC,EAAML,EAAAnT,MACfsD,EAAMY,KAAKC,IAAIb,EAAKkQ,EAAOlQ,KAC3BD,EAAOa,KAAKC,IAAId,EAAMmQ,EAAOnQ,MAC7BwP,EAAS3O,KAAKE,IAAIyO,EAAQW,EAAOX,QACjCC,EAAQ5O,KAAKE,IAAI0O,EAAOU,EAAOV,MACjC,CAAC,OAAAW,GAAAL,EAAA5E,EAAAiF,EAAA,SAAAL,EAAAM,GAAA,CAED,IAAMC,EAAyBtO,EAAiBM,wBAE1CiO,EAAuB,CAC3BvQ,KAAM0P,EAAkB1P,KAAOsQ,EAAuBtQ,KACtDC,IAAKyP,EAAkBzP,IAAMqQ,EAAuBrQ,KAGhDuQ,EAAkB,CACtB/N,MAAOT,EAAiBK,YACxBE,OAAQP,EAAiBI,cAGrBjC,EAAYF,EAAMyP,EAAkBzP,IAAM4F,EAAY1F,UACtDC,EAAaJ,EAAO0P,EAAkB1P,KAAO6F,EAAYzF,WAEzDmC,EAAS1B,KAAKC,IAAI,EAAG0O,EAASvP,GAC9BwC,EAAQ5B,KAAKC,IAAI,EAAG2O,EAAQzP,GAElC1D,EAAOmU,aAAe,CAAChO,MAAAA,EAAOF,OAAAA,GAC9BjG,EAAOoU,eAAiB,CAACzQ,IAAKE,EAAWH,KAAMI,GAC/C9D,EAAOkU,gBAAkBA,EACzBlU,EAAOiU,qBAAuBA,CAChC,CACF,GAEA,CAAA7T,IAAA,mBAAAC,MAGG,SAAA+E,GAKD,IAAMZ,EAAM,KACN6P,EAAIjP,GAAuB,OAAfA,EAAKe,MAAiB5B,KAAKE,IAAID,EAAKY,EAAKe,OAAS,EAC9D2H,EAAI1I,GAAwB,OAAhBA,EAAKa,OAAkB1B,KAAKE,IAAID,EAAKY,EAAKa,QAAU,EAEtE,GAAI3F,KAAKqH,YACPrH,KAAKgU,YAAY3I,MAAM4I,UAAY,aAAHrI,OAAgBmI,EAAC,QAAAnI,OAAO4B,EAAC,WACpD,CACL,IAAMnC,EAAQrL,KAAK+J,aAAcsB,MAChCA,EAAM6I,SAA6BH,EAAI,GAAHnI,OAAMmI,EAAC,MAAO,OAClD1I,EAAMI,UAA8B+B,EAAI,GAAH5B,OAAM4B,EAAC,MAAO,MACtD,CACF,GAEA,CAAA1N,IAAA,oBAAAC,MAGG,SAAAoU,GAAA,IAAAC,EAAA,KAEGD,GACFA,EAAI3J,SAAQ,SAAA6J,EAA+ChU,GAAO,IAApDgD,EAAGgR,EAAHhR,IAAKD,EAAIiR,EAAJjR,KAAMyC,EAAKwO,EAALxO,MAAOF,EAAM0O,EAAN1O,OAAQ2O,EAAOD,EAAPC,QAASC,EAAOF,EAAPE,QACzC5J,EAAQyJ,EAAK1J,UAAUrK,EAAQ+T,EAAKlM,QACtCyC,IACFA,EAAMU,MAAMxK,SAAW,WACvB8J,EAAMU,MAAMmJ,UAAY,aACxB7J,EAAMU,MAAM4I,UAAY,aAAHrI,OAAgBxI,EAAI,QAAAwI,OAAOvI,EAAG,YACrCrC,IAAV6E,IACF8E,EAAMU,MAAMxF,MAAQA,EAAQ,WAEf7E,IAAX2E,IACFgF,EAAMU,MAAM1F,OAASA,EAAS,MAE/BgF,EAAMU,MAAMjI,UAAsBpC,IAAAsT,EAAA,KAAAA,EAAA,KAElC3J,EAAMU,MAAMhI,SAAqBrC,IAAAuT,EAAA,KAAAA,EAAA,KAGtC,GAEJ,GAAC,CAAAzU,IAAA,eAAAC,OAAA0U,GAAAjI,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,GAEO,SAAAgI,EAAmBhE,GAAoB,IAAAxI,EAAAC,EAAAC,EAAAC,EAAA,OAAAoE,EAAAA,EAAAA,KAAAI,GAAA,SAAA8H,GAAA,cAAAA,EAAA5H,GAAA,OACtC7E,EAA8ClI,KAA9CkI,OAAQC,EAAsCnI,KAAtCmI,MAAOC,EAA+BpI,KAA/BoI,cAAeC,EAAgBrI,KAAhBqI,aACrCrI,KAAKkI,OAASwI,EAAMkE,MACpB5U,KAAKmI,MAAQuI,EAAMmE,KACnB7U,KAAKoI,cAAgBsI,EAAMwB,aAC3BlS,KAAKqI,aAAeqI,EAAMyB,YAC1BnS,KAAKiH,cAAa,KAAAA,eAAA,KAAAiB,SAAAA,GAAA,KAAAC,QAAAA,EAElBnI,KAAKmH,mBAAkB,KAAAA,oBAAA,KAAAiB,gBAAAA,GAAA,KAAAC,eAAAA,EAAA,cAAAsM,EAAA3H,EAAA,MAAA0H,EAAA,UAIxB,SAZyBI,GAAA,OAAAL,EAAAvH,MAAC,KAADpM,UAAA,KAAAhB,IAAA,sBAAAC,MAclB,WACN,GAAIC,KAAK4G,aAAc,CACrB,IAAAmO,EAAgC/U,KAAKoH,oBAA9B7D,EAASwR,EAATxR,UAAWC,EAAUuR,EAAVvR,WAClBwR,EAAoBhV,KAAK4G,aAAlBvD,EAAG2R,EAAH3R,IAAKD,EAAI4R,EAAJ5R,KACZpD,KAAK4G,aAAe,KACpB5G,KAAKoH,oBAAqB6N,mBAAmB,CAC3C5R,IAAKE,EAAYF,EACjBD,KAAMI,EAAaJ,GAEvB,CACF,GAAC,CAAAtD,IAAA,UAAAC,MAEM,SAAQM,GAAa,IAAA6U,EAAAC,EAAA,KAI1B,OAHI9U,IAAU+U,MACZ/U,EAAQL,KAAKiI,OAAOlH,OAAS,QAECC,KAAd,QAAXkU,EAAAlV,KAAKiI,cAAM,IAAAiN,OAAA,EAAXA,EAAc7U,SAAoBW,EAAA,CAGnCC,eAAgB,WAAF,IAAGkC,EAAArC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAiC,CAAC,EAAC,OAAEqU,EACpDE,uBAAKrJ,OAAAC,OAAAD,OAAAC,OAAA,GAA2B9I,GAAO,IAAE9C,MAAAA,IAAO,EAE1D,GAAC,CAAAP,IAAA,yBAAAC,MAEO,SAAuBoD,GAAqC,IAAAmS,EAAA,KAClE,GAAInS,EAAQ9C,OAASL,KAAKkI,QAAU/E,EAAQ9C,OAASL,KAAKmI,MACxDnI,KAAK0K,UAAUvH,EAAQ9C,MAAQL,KAAKkI,QAAQjH,eAAekC,QAG3D,GADAA,EAAQ9C,MAAQ4D,KAAKE,IAAIhB,EAAQ9C,MAAOL,KAAKiI,OAAOlH,OAAS,GACpC,WAArBoC,EAAQU,SAAuB,CACjC,IAAMS,EAActE,KAAKyG,QAAS8O,6BAA6BpS,GACxDU,EAAYV,EAAZU,SACP7D,KAAKgI,iCAAgC,KAAAZ,oBAAAoO,gBAAAxJ,OAAAC,OAAA3H,EAAA,CAELT,SAAAA,KAC5B,kBAAGyR,EAAG7O,QAAK8O,6BAASpS,EAA6B,IAAQ,kBACzDmS,EAAOvN,sBAAK,IAAqB,IAErC/H,KAAK+H,sBAAwB5E,CAC/B,MACEnD,KAAKyG,QAASgP,IAAMtS,CAG1B,GAEA,CAAArD,IAAA,6BAAAC,MAGG,SAAAoU,GAED,IAAO9T,GAASL,KAAK+H,uBAAyB,CAAC,GAAxC1H,MACHA,SAAS8T,GAAAA,EAAKjF,IAAI7O,IACpBL,KAAKgI,iCACHhI,KAAKyG,QAAS8O,6BAA6BvV,KAAK+H,uBAGtD,GAEA,CAAAjI,IAAA,eAAAC,MAGG,WAEDC,KAAK+J,aAAcqI,cACjB,IAAIsD,EAAAA,GAAkB,CAACd,MAAO5U,KAAKkI,OAAQ2M,KAAM7U,KAAKmI,QAE1D,GAAC,CAAArI,IAAA,oBAAAC,MAEO,WACNC,KAAK+J,aAAcqI,cACjB,IAAIuD,EAAAA,GAAuB,CACzBf,MAAO5U,KAAKoI,cACZyM,KAAM7U,KAAKqI,eAGjB,GAAC,CAAAvI,IAAA,iBAAAW,IAED,WAAyB,IAAAmV,EAAA,KAQvB,OANK5V,KAAK0I,yBACR1I,KAAK0I,uBAAyB,IAAIuH,SAAQ,SAACC,EAAS2F,GAClDD,EAAKjN,wBAA0BuH,EAC/B0F,EAAKhN,wBAA0BiN,CACjC,KAEK7V,KAAK0I,sBACd,GAAC,CAAA5I,IAAA,+BAAAC,MAEO,SAA6B+V,GACE,OAAjC9V,KAAK4I,yBACP5I,KAAK4I,wBAAwBkN,GAE/B9V,KAAK+V,2BACP,GAAC,CAAAjW,IAAA,0BAAAC,MAEO,WAAuB,IAAAiW,EAAA,KAGzBhW,KAAK0I,wBAA0D,OAAhC1I,KAAK6I,yBAEtC7I,KAAK6I,uBAAyBrE,uBAAsB,kBAAGA,uBACrD,kBAAsBwR,EAAMC,+BAAK,OAGvC,GAAC,CAAAnW,IAAA,gCAAAC,MAEO,WAC+B,OAAjCC,KAAK2I,yBACP3I,KAAK2I,0BAEP3I,KAAK+V,2BACP,GAAC,CAAAjW,IAAA,4BAAAC,MAEO,WACNC,KAAK0I,uBAAyB,KAC9B1I,KAAK2I,wBAA0B,KAC/B3I,KAAK4I,wBAA0B,KAC/B5I,KAAK6I,uBAAyB,IAChC,GAEA,CAAA/I,IAAA,0BAAAC,MAGG,WAEDC,KAAKsJ,UAAUtJ,KAAKuJ,cACtB,GAKA,CAAAzJ,IAAA,eAAAC,MAEQ,WAAY,GAMpB,CAAAD,IAAA,uBAAAC,MACQ,SAAqBmW,GAA8B,IAAAC,EAEzD,GAAgB,QAAhBA,EAAInW,KAAKyG,eAAO,IAAA0P,GAAZA,EAAcvI,gBAAiB,KACLwI,EADKC,GAAAjD,EAAAA,EAAAA,GACZ8C,GAAO,IAA5B,IAAAG,EAAAhD,MAAA+C,EAAAC,EAAAtJ,KAAAuG,MAA4B,KAAjBgD,EAAMF,EAAArW,MACfC,KAAK+G,cAAcoC,IACjBmN,EAAO1L,OACP0L,EAAOC,YAEX,CAAC,OAAA/C,GAAA6C,EAAA9H,EAAAiF,EAAA,SAAA6C,EAAA5C,GAAA,CACDzT,KAAKwW,kBACP,CAKAxW,KAAKyW,0BACLzW,KAAKkH,eAAgB,EACrBlH,KAAKiH,eAAgB,CACvB,KA9KC,IAAAwN,EAnNwBrE,EAFxBP,EA7HuB1C,EAFvBZ,CAkgBA,CAzyBA,GAszBH,SAASiD,EAAezP,GACtB,IAAM2W,EAAQ3W,EAAQ4W,WAAW5W,GAAS6W,IAC1C,OAAOC,OAAOC,MAAMJ,GAAS,EAAIA,CACnC,CAGA,SAASK,EAAiB1H,GACxB,GAAwB,OAApBA,EAAG2H,aACL,OAAO3H,EAAG2H,aAEZ,GAAyB,OAArB3H,EAAG4H,cACL,OAAO5H,EAAG4H,cAEZ,IAAMC,EAAa7H,EAAG6H,WACtB,OAAIA,GAAcA,EAAWC,WAAaC,KAAKC,wBACrCH,EAA0BI,MAE7B,IACT,CAIA,SAASC,EAAoBlI,GAG3B,IAH+D,IACzDmI,EAAgC,GAClCC,EAFmD3W,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAE5BuO,EAAM0H,EAAiB1H,GACrC,OAAboI,GACED,EAAUjN,KAAKkN,GACfA,EAASV,EAAiBU,GAE5B,OAAOD,CACT,CAEA,SAASrN,EAAqBkF,GAAoC,IAC5DqI,GAAa,EACjB,OAAOH,EAAoBlI,EAF6BvO,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,IAEZwN,QAAO,SAACtB,GAClD,GAAI0K,EACF,OAAO,EAET,IAAMrM,EAAQoE,iBAAiBzC,GAE/B,OADA0K,EAAgC,UAAnBrM,EAAMxK,SACO,YAAnBwK,EAAMG,QACf,GACF,yLCj8BGkK,EAAA,SAAAiC,GAQD,SAAAjC,EAAYhF,GAAY,IAAAvR,EAGC,OAHDC,EAAAA,EAAAA,GAAA,KAAAsW,IACtBvW,GAAA0C,EAAAA,EAAAA,GAAA,KAAA6T,EAAA,CAAMA,EAAkBkC,UAAW,CAACC,SAAS,MACxCjD,MAAQlE,EAAMkE,MACnBzV,EAAK0V,KAAOnE,EAAMmE,KAAK1V,CACzB,CAAC,OAAAS,EAAAA,EAAAA,GAAA8V,EAAAiC,IAAA9X,EAAAA,EAAAA,GAAA6V,EAAA,CAZA,EAYAoC,EAAAA,EAAAA,GAZAC,QAGMrC,EAAAkC,UAAY,eAYd,IAAMjC,EAAuB,SAAAqC,GAMlC,SAAArC,EAAYjF,GAAY,IAAAnM,EAGC,OAHDnF,EAAAA,EAAAA,GAAA,KAAAuW,IACtBpR,GAAA1C,EAAAA,EAAAA,GAAA,KAAA8T,EAAA,CAAMA,EAAuBiC,UAAW,CAACC,SAAS,MAC7CjD,MAAQlE,EAAMkE,MACnBrQ,EAAKsQ,KAAOnE,EAAMmE,KAAKtQ,CACzB,CAAC,OAAA3E,EAAAA,EAAAA,GAAA+V,EAAAqC,IAAAnY,EAAAA,EAAAA,GAAA8V,EAAA,CAViC,EAUjCmC,EAAAA,EAAAA,GAVyCC,QACnCpC,EAAAiC,UAAY,oBAYd,IAAMvF,EAAc,SAAA4F,GAGzB,SAAA5F,IAAA,OAAAjT,EAAAA,EAAAA,GAAA,KAAAiT,IAAAxQ,EAAAA,EAAAA,GAAA,KAAAwQ,EAAA,CACQA,EAAcuF,UAAW,CAACC,SAAS,IAC3C,CAAC,OAAAjY,EAAAA,EAAAA,GAAAyS,EAAA4F,IAAApY,EAAAA,EAAAA,GAAAwS,EAAA,CALwB,EAKxByF,EAAAA,EAAAA,GALgCC,QAC1B1F,EAAAuF,UAAY,+QCrBlBM,eAAAC,OAAA,kBAAAlZ,EAAAA,gZCgCI,IAAMQ,EAAqC,SAAC2Y,GAAa,OAAEA,CAAG,EACxD7Y,EAAiD,SAC5D6Y,EACAnJ,GAAW,OACXhP,EAAAA,EAAAA,IAAGC,IAAAA,GAAAC,EAAAA,EAAAA,GAAA,eAAI8O,EAAMoJ,KAAKC,UAAKF,EAAU,KAAM,GAAI,EAEvCG,EAAiC,SAAAC,GAUrC,SAAAD,EAAYE,GAAc,IAAAtZ,EAExB,IAFwBC,EAAAA,EAAAA,GAAA,KAAAmZ,IACxBpZ,GAAA0C,EAAAA,EAAAA,GAAA,KAAA0W,EAAA,CAAME,KAVRC,aAAmC,KACnCvZ,EAAA+I,OAAS,EACT/I,EAAAgJ,OAAS,EACThJ,EAAAwZ,YAAqC,SAACP,EAASnJ,GAAW,OAAE1P,EAC1D6Y,EAAsBnJ,EAAK9P,EAAG+I,OAAK,EACrC/I,EAAAyZ,aAAyB,SAACR,EAASnJ,GAAW,OAAExP,EAC9C2Y,EAAuBnJ,EAAK9P,EAAG+I,OAAK,EACtC/I,EAAA8I,OAAmB,GAIbwQ,EAAKjX,OAASqX,EAAAA,GAAAA,MAChB,MAAM,IAAI7P,MACR,kEAEH,OAAA7J,CACH,CAAC,OAAAS,EAAAA,EAAAA,GAAA2Y,EAAAC,IAAA3Y,EAAAA,EAAAA,GAAA0Y,EAAA,EAAAzY,IAAA,SAAAC,MAED,SAAOwG,GACDA,GACFvG,KAAK8Y,cAAcvS,GAErB,IAAMwS,EAA0B,GAEhC,GAAI/Y,KAAKkI,QAAU,GAAKlI,KAAKmI,OAASnI,KAAKkI,OACzC,IAAK,IAAA8G,EAAK,KAAO9G,OAAO8G,GAAG,KAAQ7G,MAAM6G,IACvC+J,EAAcxO,KAAKvK,KAAKiI,OAAO+G,IAGnC,OAAOgK,EAAAA,EAAAA,GAAOD,EAAe/Y,KAAK4Y,aAAc5Y,KAAK2Y,YACvD,GAAC,CAAA7Y,IAAA,SAAAC,MAED,SAAO0Y,EAAepE,GAA0C,IAAvC9N,GAAuC0S,EAAAA,EAAAA,GAAA5E,EAAA,GAAjC,GAC7BrU,KAAK8Y,cAAcvS,GACnB,IAAM2S,EAAelZ,KAAKiI,SAAW1B,EAAOlH,MAO5C,OANAW,KAAKiI,OAAS1B,EAAOlH,OAAS,GAC1BW,KAAK0Y,aACP1Y,KAAKmZ,yBAAyBV,EAAMlS,GAEpCvG,KAAKoZ,YAAYX,EAAMlS,GAElB2S,EAAeG,EAAAA,GAAWrZ,KAAKsZ,QACxC,GAAC,CAAAxZ,IAAA,2BAAAC,OAAAwZ,GAAA/M,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,GAEO,SAAAC,EACN8L,EACAlS,GAAoC,IAAA0C,EAAA,OAAAwD,EAAAA,EAAAA,KAAAI,GAAA,SAAAC,GAAA,cAAAA,EAAAC,GAAA,cAAAD,EAAAC,EAAA,EAEX/M,KAAK0Y,aAAcc,mBAC1CjT,EAAO7G,QAAU,CAAC,GACnB,OAFeoN,EAAAU,IAIRvE,EAAcwP,EAAKvB,WACzBlX,KAAKyZ,iBAAiBxQ,EAAa1C,IAErCvG,KAAK0Y,aAAcrZ,MAAQW,KAAKiI,OAAO,cAAA6E,EAAAE,EAAA,MAAAL,EAAA,UACxC,SAZqCM,EAAAc,GAAA,OAAAwL,EAAArM,MAAC,KAADpM,UAAA,KAAAhB,IAAA,gBAAAC,MAc9B,SAAcwG,GAAoC,IAAAhC,EAAA,KACjDjF,EAA2BiH,EAA3BjH,WAAYE,EAAe+G,EAAf/G,YACfF,IACFU,KAAK2Y,YAAc,SAACP,EAAMnJ,GAAG,OAAE3P,EAAG8Y,EAAenJ,EAAK1K,EAAG2D,OAAK,GAE5D1I,IACFQ,KAAK4Y,aAAe,SAACR,EAAMnJ,GAAG,OAAEzP,EAAG4Y,EAAgBnJ,EAAK1K,EAAG2D,OAAK,EAEpE,GAAC,CAAApI,IAAA,mBAAAC,MAEO,SACNkJ,EACA1C,GAEIvG,KAAK0Y,cACP1Y,KAAK0Y,aAAagB,eAEpB,IAAOha,EAA2B6G,EAA3B7G,OAAQC,EAAmB4G,EAAnB5G,SAAUN,EAASkH,EAATlH,MACzBW,KAAK0Y,aAAe,IAAIpS,EAAAA,GAAY,CAAC2C,YAAAA,EAAavJ,OAAAA,EAAQC,SAAAA,IAC1DK,KAAK0Y,aAAarZ,MAAQA,EAC1BW,KAAK0Y,aAAaiB,WACpB,GAAC,CAAA7Z,IAAA,cAAAC,MAEO,SAAY0Y,EAAiBlS,GAAoC,IAAA0E,EAAA,KACjEhC,EAAcwP,EAAKvB,WACrBjO,GAAwC,IAAzBA,EAAYkO,WAC7BlO,EAAYhE,iBAAiB,gBAAgB,SAACsJ,GAC5CtD,EAAK/C,OAASqG,EAAEqG,MAChB3J,EAAK9C,MAAQoG,EAAEsG,KACf5J,EAAK2O,SAAS3O,EAAKqO,SACrB,IACAtZ,KAAKyZ,iBAAiBxQ,EAAa1C,GAEvC,GAAC,CAAAzG,IAAA,eAAAC,MAED,WAAY,IAAA8Z,EACO,QAAjBA,EAAA7Z,KAAK0Y,oBAAY,IAAAmB,GAAjBA,EAAmBH,cACrB,GAAC,CAAA5Z,IAAA,cAAAC,MAED,WAAW,IAAA+Z,EACQ,QAAjBA,EAAA9Z,KAAK0Y,oBAAY,IAAAoB,GAAjBA,EAAmBH,WACrB,KAzDC,IAAAJ,CAyDA,CApGoC,CAAQQ,EAAAA,IAuGlC3Z,GAAa4Z,EAAAA,EAAAA,IAAUzB,oSCnB9BlF,EAEJ,SAAArE,EAAAN,GAEA,IAAMH,EAAkBS,EAAAiL,KACxB,QAAI,IACF1L,EAAA,OAAO,MAWN2E,EAXMC,GAAAC,EAAAA,EAAAA,GAES7E,GASf,IATH,IAAA4E,EAAAE,MAAAH,EAAAC,EAAApG,KAAAuG,MASG,KAAA4G,EATQlL,EAAAkE,EAAAnT,MASmD,QAA3Dma,EAAAlL,EAA2DmL,YAAA,IAAAD,GAA3DA,EAAA/K,KAAAH,EACCN,GACA,GAG6B2E,EAAKrE,EAAAN,EAAA,QAAA8E,GAAAL,EAAA5E,EAAAiF,EAAA,SAAAL,EAAAM,GAAA,CAEtC,OAAO,CAAI,EASP2G,EAAkC,SAAApL,GACtC,IAAIN,EAAQH,EACZ,EAAG,KAAA8L,EACD,QAAI,KAAU3L,EAAIM,EAAAsL,MAChB,OAEF/L,EAAkBG,EAAAuL,MACTpV,OACTmK,GAAMA,EAAAN,CACR,OAA4B,KAAT,QAAS2L,EAAT9L,SAAA,IAAA8L,OAAA,EAAAA,EAAAvV,MAAY,EAG3ByV,EAA6B,SAAAvL,GAGjC,IAAK,IAAIN,EAASA,EAAaM,EAAAsL,KAAyBtL,EAAAN,EAAA,CACtD,IAAIH,EAAkBG,EAAAuL,KACtB,QAAI,IACF1L,EAAOG,EAAAuL,KAA0C1L,EAAA,IAAAxM,SAC5C,GAAIwM,EAASW,IAAIF,GAGtB,MAEFT,EAASvJ,IAAIgK,GACbwL,EAAqB9L,EACtB,GAUH,SAASqF,EAAyC/E,QAAA,IAC5ChP,KAAKia,MACwBG,EAAApa,MAC1B,KAAWsa,KACUtL,EAAAuL,EAE1Bva,OAAgB,KAAAsa,KAAAtL,CAEpB,CAuBA,SAASjC,EAEPiC,GAEgB,IADhBN,EAAA5N,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACgByN,EAAAzN,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,KAEVyZ,EAAQva,KAAKya,KACF1G,EAAK,KAAAkG,KACtB,QAAI,IAA4ClG,GAAlB,IAG9BA,EAAAjP,KACM,GAAA4J,EAAM,GAAAtF,MAIRC,QAASkR,GAAmB,IAAU,IAAAvL,EAAQT,EAC5CS,EAAqCuL,EAAAxZ,OACNiO,IAAMqE,EAAAkH,EAAAvL,IAAA,GAAAoL,EAAAG,EAAAvL,SAErB,MAATuL,IAIsBlH,EAAyBkH,GACxD,GAA+BH,EAAAG,SAGjClH,EAA+BrT,KAAMgP,EAEzC,CAKA,IAAMwL,EAAwB,SAAAxL,GAAA,IAAA0L,EAAAC,EACvB3L,EAAkBxN,MAAiB+M,EAAAA,GAAAA,QAEpC,QADiBmM,EAAA1L,EAAA4L,YACjB,IAAAF,IADiB1L,EAAA4L,KAEA7N,GAA8B,QAA9B4N,EAAA3L,EAA8B6L,YAAA,IAAAF,IAA9B3L,EAA8B6L,KAAA9G,GAClD,EAoBmBN,EAAA,SAAAqH,GAAtB,SAAArH,IAAA,IAAAtU,EAY4D,OAZ5DC,EAAAA,EAAAA,GAAA,KAAAqU,IAAAtU,GAAA0C,EAAAA,EAAAA,GAAA,KAAA4R,EAAA3S,YAYmCmZ,UAAA,EAAyB9a,CAgF3D,QAAAS,EAAAA,EAAAA,GAAA6T,EAAAqH,IAAAjb,EAAAA,EAAAA,GAAA4T,EAAA,EAAA3T,IAAA,OAAAC,MAzEU,SACPiP,EACAN,EACAH,IAEAwM,EAAAA,EAAAA,GAAAtH,EAAA,cAAAsH,CAAA,CAAmB/L,EAAMN,EAAQH,IACPgM,EAAAva,MAC1BA,KAAKgb,YAAmBhM,EAAAiM,IACzB,IAAAnb,IAAA,OAAAC,MAcQ,SACPiP,GACsB,IAAAkM,EAAAC,EAAtBzM,IAAA5N,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEIkO,IAAgBhP,KAAKgb,cACvBhb,KAAKgb,YAEHhM,EAAKA,EAEL,QAFKkM,EAAA,KAAAE,mBAEL,IAAAF,GAFKA,EAAA/L,KAAA,MAMP,QAJOgM,EAAA,KAAAzB,oBAIP,IAAAyB,GAJOA,EAAAhM,KAAA,OAI8BT,IACN2E,EAAArT,KAAAgP,GAAAoL,EAAApa,MAElC,IAAAF,IAAA,WAAAC,MAYD,SAAS2O,GACP,IAAIM,EAAAA,EAAAA,IAAmBhP,KAAKqb,MAC1Brb,KAAKqb,KAAOC,KAAkB5M,EAAA1O,UACzB,CAML,IAAMgP,GAAAuM,EAAAA,EAAAA,GAAiBvb,KAAKqb,KAAOZ,MACnCzL,EAAUhP,KAAKwb,MACd9M,EAAA1O,KAAKqb,KAAyBC,KAAsBtM,EAAAhP,KAAM,EAC5D,CACF,IAAAF,IAAA,eAAAC,MAQS,WAAiB,IAAAD,IAAA,cAAAC,MACjB,WAAgB,KA3FN,CAAuB2O,EAAAA,0XC9Q3C,IADA,IAAM6L,EAAM,IAAIvT,IACPyU,EAAWpI,EAAKoI,GAAK/M,EACxB+M,IAAIlB,EAAKpR,IAAIoF,EAAAkN,GAAAA,GAEnB,OAAOlB,CAAG,EAqcCC,GAlcbnH,EAAAA,EAAAA,IAAA,SAAAqI,GAGE,SAAAC,EAAYpN,GAAA,IAAApP,EAEV,IAFUC,EAAAA,EAAAA,GAAA,KAAAuc,GACVxc,GAAA0C,EAAAA,EAAAA,GAAA,KAAA8Z,EAAA,CAAMpN,IACOA,EAAA/M,OAAkB+Y,EAAAA,GAAAA,MAC7B,MAAUvR,MAAM,wDAAA7J,CAEnB,QAAAS,EAAAA,EAAAA,GAAA+b,EAAAD,IAAA7b,EAAAA,EAAAA,GAAA8b,EAAA,EAAA7b,IAAA,KAAAC,MAEO,SACNwO,EACA8E,EACA3E,GAEA,IAAI6L,OAAA,IAEF7L,EAAWA,EAAA2E,OACkB,IACrBA,IAAAkH,EAAAlH,GAEV,IAIEH,EAJIuI,EAAO,GACErB,EAAA,GACXpL,EAAQ,EAAAmE,GAAAC,EAAAA,EAAAA,GACO7E,GACjB,IADF,IAAA4E,EAAAE,MAAAH,EAAAC,EAAApG,KAAAuG,MACE,KADSD,EAAAH,EAAAnT,MACT0b,EAAKzM,GAAiBuL,EAAYA,EAASlH,EAC3CrE,GAAgBA,EAAgBoL,EAAApL,GAChCN,EAAA2E,EAAArE,GAAAA,GAAA,QAAAwE,GAAAL,EAAA5E,EAAAiF,EAAA,SAAAL,EAAAM,GAAA,CAEF,MAAO,CACLmI,OAAAxB,EACAyB,KAAAJ,EAEH,IAAA3b,IAAA,SAAAC,MAQD,SACEwO,EACA8E,EACA3E,GAEA,OAAO1O,KAAK8b,GAAkBvN,EAAO8E,EAAiB3E,GAAUkN,MACjE,IAAA9b,IAAA,SAAAC,MAEQ,SACPsT,EAAAgB,GACyB,IAAA0H,EAAAC,GAAA/C,EAAAA,EAAAA,GAAA5E,EAAA,GAAxB3F,EAAOsN,EAAA,GAAiBzB,EAAAyB,EAAA,GAAAxB,EAAAwB,EAAA,GAQnBC,GACJR,EAAAA,EAAAA,IAAApI,GAEK6I,EAEL,KACAJ,GAAApN,EAAA6L,EAAAC,GAHwB2B,EAAAD,EAAnBN,OAAoC5O,EAAKkP,EAAhBL,KAWhC,IAAKzS,MAAMC,QAAQ4S,GAEjB,OADAjc,KAAKoc,GACEpP,EAAAmP,EAgOT,IAxNA,IAWIzP,EACA2P,EAZEtI,EAAgB,QAAhBgI,EAAW/b,KAAKoc,UAAA,IAAAL,EAAAA,EAAL/b,KAAKoc,GAKhB,GAAwB5O,EAAA,GAUhB8O,EACA,EAASC,EAAAN,EAASlb,OAElB,EAAUyb,EAAA,EAAS3P,EAAAsP,EAAApb,OAAA,EAsM1Bub,GAAsBC,GAAWC,GACZ3P,GAAA,GAAtB,OAGFoP,EAAAK,GAAAA,SACK,GAA0B,OAAbL,EAGlBM,GAAAA,SACK,GAAIxI,EAAQuI,KAAqBtP,EAEtCwP,GAAShP,EAAWgP,IACTpC,EAAAA,EAAAA,IACT6B,EAAUK,GAEZH,EAAAK,IACAF,IAAAE,SACK,GAAIzI,EAAQwI,KAAqBvP,EAEtCH,GAASW,EAAWX,IACTuN,EAAAA,EAAAA,IACT6B,EAAUM,GAEZJ,EAAAtP,IACA0P,IAAA1P,SACK,GAAIkH,EAAQuI,KAAqBtP,EAEtCH,GAASW,EAAWX,IACTuN,EAAAA,EAAAA,IACT6B,EAAUK,GAEZH,EAAWtP,KAAkCmC,EAAAA,EAAAA,IAAAqE,EAAa7F,EAAAX,EAC1D,GACAoP,EAAAK,IAAAA,IAAAzP,SACK,GAAIkH,EAAQwI,KAAqBvP,EAEtCwP,GAAShP,EAAWgP,IACTpC,EAAAA,EAAAA,IACT6B,EAAUM,GAEZJ,EAAWK,KAAwBxN,EAAAA,EAAAA,IAAWqE,EAAS4I,EACvDK,GACAL,EAAAM,IAAAA,IAAAC,SAQA,QAAI,IANA9P,IAG6BA,EAAkB+P,EACjDzP,EAAmBwP,EAAqB3P,GAASwP,EAE7BI,EAAA1I,EAAIuI,EAAQC,IAItB7P,EAAiBwC,IAAI6E,EAAQuI,IAIlC,GAAA5P,EAAAwC,IAAA6E,EAAAwI,IAAA,CAIL,IAAMhO,EAA4B8N,EAAA5b,IAAYuM,EAAAwP,IACxC9N,OAAuB,IAAiCH,EAAA0N,EAAA1N,GAAA,KAC9D,GAAgB,OAAMG,EAAA,CAGpB,IAAMH,GAAqBS,EAAAA,EAAAA,IAAeqE,EAAS4I,EAAAK,KACnDlC,EAAAA,EAAAA,IAAkB7L,EAAS4N,EAAUK,IAC5BhP,EAAAgP,GAAWjO,CACrB,MAECf,EAASgP,IAA6BpC,EAAAA,EAAAA,IAAS1L,EAAUyN,EACzDK,KAA0BxN,EAAAA,EAAAA,IAASqE,EAAW4I,EAG9CK,GAAS5N,GAAsBuN,EAAA1N,GAAA,KAEjCiO,GACD,MAvBCzP,EAAAA,EAAAA,IAAWkP,EAASM,IACpBA,SALAxP,EAAAA,EAAAA,IAAWkP,EAASK,IACpBA,IA8BN,KAAOE,GAAoB3P,GAAA,CAGzB,IAAM0B,GAAqBS,EAAAA,EAAAA,IAAeqE,EAAS7F,EAAUX,EAAA,KAC7DuN,EAAAA,EAAAA,IAAkB7L,EAAS4N,EAAUK,IAC5BhP,EAAAgP,KAAajO,CACvB,CAED,KAAO+N,GAAoBC,GAAA,CACzB,IAAMhO,EAAmB0N,EAAAK,KACT,OAAZ/N,IACSxB,EAAAA,EAAAA,IAAAwB,EAEd,CAMD,OAHAvO,KAAKoc,GAELpP,GAAkByG,EAAAA,EAAAA,IAAeJ,EAC1B7F,GAAAe,EAAAA,EACR,KAlZH,CAA8BG,EAAAA"}