{"version":3,"file":"893.82bc11f64055f3b3.js","sources":["webpack://lcn-frontend/mwc-list-item.ts","webpack://lcn-frontend/keyboard.ts","webpack://lcn-frontend/constants.ts","webpack://lcn-frontend/mwc-list-foundation.ts","webpack://lcn-frontend/mwc-list-base.ts","webpack://lcn-frontend/mwc-list.css.ts","webpack://lcn-frontend/../src/directives/repeat.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n\nimport {customElement} from 'lit/decorators.js';\n\nimport {ListItemBase} from './mwc-list-item-base.js';\nimport {styles} from './mwc-list-item.css.js';\n\nexport {GraphicType, RequestSelectedDetail} from './mwc-list-item-base.js';\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'mwc-list-item': ListItem;\n  }\n}\n\n@customElement('mwc-list-item')\nexport class ListItem extends ListItemBase {\n  static override styles = [styles];\n}\n","","","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n\nimport {MDCFoundation} from '@material/base/foundation.js';\nimport {normalizeKey} from '@material/dom/keyboard.js';\nimport {numbers, strings} from '@material/list/constants.js';\n\nimport {MDCListAdapter} from './mwc-list-adapter.js';\n\nexport type MWCListIndex = number|Set<number>;\n\nexport interface IndexDiff {\n  added: number[];\n  removed: number[];\n}\n\nexport interface SelectedDetail<T extends MWCListIndex = MWCListIndex> {\n  index: T;\n  diff: T extends Set<number>? IndexDiff: undefined;\n}\n\nexport interface ActionDetail {\n  index: number;\n}\n\nconst integerSort = (a: number, b: number) => {\n  return a - b;\n};\n\nexport type SingleSelectedEvent = CustomEvent<SelectedDetail<number>>;\nexport type MultiSelectedEvent = CustomEvent<SelectedDetail<Set<number>>>;\nexport type SelectedEvent = SingleSelectedEvent|MultiSelectedEvent;\n\nconst findIndexDiff = (oldSet: Set<number>, newSet: Set<number>): IndexDiff => {\n  const oldArr = Array.from(oldSet);\n  const newArr = Array.from(newSet);\n  const diff: IndexDiff = {added: [], removed: []};\n  const oldSorted = oldArr.sort(integerSort);\n  const newSorted = newArr.sort(integerSort);\n\n  let i = 0;\n  let j = 0;\n  while (i < oldSorted.length || j < newSorted.length) {\n    const oldVal = oldSorted[i];\n    const newVal = newSorted[j];\n\n    if (oldVal === newVal) {\n      i++;\n      j++;\n      continue;\n    }\n\n    if (oldVal !== undefined && (newVal === undefined || oldVal < newVal)) {\n      diff.removed.push(oldVal);\n      i++;\n      continue;\n    }\n\n    if (newVal !== undefined && (oldVal === undefined || newVal < oldVal)) {\n      diff.added.push(newVal);\n      j++;\n      continue;\n    }\n  }\n\n  return diff;\n};\n\nconst ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];\n\nexport function isIndexSet(selectedIndex: MWCListIndex):\n    selectedIndex is Set<number> {\n  return selectedIndex instanceof Set;\n}\n\nexport function isEventMulti(evt: SelectedEvent): evt is MultiSelectedEvent {\n  return isIndexSet(evt.detail.index);\n}\n\nexport const createSetFromIndex = (index: MWCListIndex) => {\n  const entry = index === numbers.UNSET_INDEX ? new Set<number>() : index;\n  return isIndexSet(entry) ? new Set(entry) : new Set([entry]);\n};\n\nexport class MDCListFoundation extends MDCFoundation<MDCListAdapter> {\n  static override get strings() {\n    return strings;\n  }\n\n  static override get numbers() {\n    return numbers;\n  }\n\n\n  static override get defaultAdapter(): MDCListAdapter {\n    return {\n      focusItemAtIndex: () => undefined,\n      getFocusedElementIndex: () => 0,\n      getListItemCount: () => 0,\n      isFocusInsideList: () => false,\n      isRootFocused: () => false,\n      notifyAction: () => undefined,\n      notifySelected: () => undefined,\n      getSelectedStateForElementIndex: () => false,\n      setDisabledStateForElementIndex: () => undefined,\n      getDisabledStateForElementIndex: () => false,\n      setSelectedStateForElementIndex: () => undefined,\n      setActivatedStateForElementIndex: () => undefined,\n      setTabIndexForElementIndex: () => undefined,\n      setAttributeForElementIndex: () => undefined,\n      getAttributeForElementIndex: () => null,\n    };\n  }\n\n  protected isMulti_ = false;\n  private wrapFocus_ = false;\n  private isVertical_ = true;\n  private selectedIndex_: MWCListIndex = numbers.UNSET_INDEX;\n  private focusedItemIndex_ = numbers.UNSET_INDEX;\n  private useActivatedClass_ = false;\n  private ariaCurrentAttrValue_: string|null = null;\n\n  constructor(adapter?: Partial<MDCListAdapter>) {\n    super({...MDCListFoundation.defaultAdapter, ...adapter});\n  }\n\n  /**\n   * Sets the private wrapFocus_ variable.\n   */\n  setWrapFocus(value: boolean) {\n    this.wrapFocus_ = value;\n  }\n\n  /**\n   * Sets the private wrapFocus_ variable.\n   */\n  setMulti(value: boolean) {\n    this.isMulti_ = value;\n\n    const currentIndex = this.selectedIndex_;\n\n    if (value) {\n      // number to set\n      if (!isIndexSet(currentIndex)) {\n        const isUnset = currentIndex === numbers.UNSET_INDEX;\n        this.selectedIndex_ = isUnset ? new Set() : new Set([currentIndex]);\n      }\n    } else {\n      // set to first sorted number in set\n      if (isIndexSet(currentIndex)) {\n        if (currentIndex.size) {\n          const vals = Array.from(currentIndex).sort(integerSort);\n          this.selectedIndex_ = vals[0];\n        } else {\n          this.selectedIndex_ = numbers.UNSET_INDEX;\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the isVertical_ private variable.\n   */\n  setVerticalOrientation(value: boolean) {\n    this.isVertical_ = value;\n  }\n\n  /**\n   * Sets the useActivatedClass_ private variable.\n   */\n  setUseActivatedClass(useActivated: boolean) {\n    this.useActivatedClass_ = useActivated;\n  }\n\n  getSelectedIndex(): MWCListIndex {\n    return this.selectedIndex_;\n  }\n\n  setSelectedIndex(index: MWCListIndex) {\n    if (!this.isIndexValid_(index)) {\n      return;\n    }\n\n    if (this.isMulti_) {\n      this.setMultiSelectionAtIndex_(createSetFromIndex(index));\n    } else {\n      this.setSingleSelectionAtIndex_(index as number);\n    }\n  }\n\n  /**\n   * Focus in handler for the list items.\n   */\n  handleFocusIn(_: FocusEvent, listItemIndex: number) {\n    if (listItemIndex >= 0) {\n      this.adapter.setTabIndexForElementIndex(listItemIndex, 0);\n    }\n  }\n\n  /**\n   * Focus out handler for the list items.\n   */\n  handleFocusOut(_: FocusEvent, listItemIndex: number) {\n    if (listItemIndex >= 0) {\n      this.adapter.setTabIndexForElementIndex(listItemIndex, -1);\n    }\n\n    /**\n     * Between Focusout & Focusin some browsers do not have focus on any\n     * element. Setting a delay to wait till the focus is moved to next element.\n     */\n    setTimeout(() => {\n      if (!this.adapter.isFocusInsideList()) {\n        this.setTabindexToFirstSelectedItem_();\n      }\n    }, 0);\n  }\n\n  /**\n   * Key handler for the list.\n   */\n  handleKeydown(\n      event: KeyboardEvent, isRootListItem: boolean, listItemIndex: number) {\n    const isArrowLeft = normalizeKey(event) === 'ArrowLeft';\n    const isArrowUp = normalizeKey(event) === 'ArrowUp';\n    const isArrowRight = normalizeKey(event) === 'ArrowRight';\n    const isArrowDown = normalizeKey(event) === 'ArrowDown';\n    const isHome = normalizeKey(event) === 'Home';\n    const isEnd = normalizeKey(event) === 'End';\n    const isEnter = normalizeKey(event) === 'Enter';\n    const isSpace = normalizeKey(event) === 'Spacebar';\n\n    if (this.adapter.isRootFocused()) {\n      if (isArrowUp || isEnd) {\n        event.preventDefault();\n        this.focusLastElement();\n      } else if (isArrowDown || isHome) {\n        event.preventDefault();\n        this.focusFirstElement();\n      }\n\n      return;\n    }\n\n    let currentIndex = this.adapter.getFocusedElementIndex();\n    if (currentIndex === -1) {\n      currentIndex = listItemIndex;\n      if (currentIndex < 0) {\n        // If this event doesn't have a mdc-deprecated-list-item ancestor from\n        // the current list (not from a sublist), return early.\n        return;\n      }\n    }\n\n    let nextIndex;\n    if ((this.isVertical_ && isArrowDown) ||\n        (!this.isVertical_ && isArrowRight)) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusNextElement(currentIndex);\n    } else if (\n        (this.isVertical_ && isArrowUp) || (!this.isVertical_ && isArrowLeft)) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusPrevElement(currentIndex);\n    } else if (isHome) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusFirstElement();\n    } else if (isEnd) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusLastElement();\n    } else if (isEnter || isSpace) {\n      if (isRootListItem) {\n        // Return early if enter key is pressed on anchor element which triggers\n        // synthetic MouseEvent event.\n        const target = event.target as Element | null;\n        if (target && target.tagName === 'A' && isEnter) {\n          return;\n        }\n        this.preventDefaultEvent(event);\n        this.setSelectedIndexOnAction_(currentIndex, true);\n      }\n    }\n\n    this.focusedItemIndex_ = currentIndex;\n\n    if (nextIndex !== undefined) {\n      this.setTabindexAtIndex_(nextIndex);\n      this.focusedItemIndex_ = nextIndex;\n    }\n  }\n\n  /**\n   * Click handler for the list.\n   */\n  handleSingleSelection(\n      index: number, isInteraction: boolean, force?: boolean) {\n    if (index === numbers.UNSET_INDEX) {\n      return;\n    }\n\n    this.setSelectedIndexOnAction_(index, isInteraction, force);\n    this.setTabindexAtIndex_(index);\n    this.focusedItemIndex_ = index;\n  }\n\n  /**\n   * Focuses the next element on the list.\n   */\n  focusNextElement(index: number) {\n    const count = this.adapter.getListItemCount();\n    let nextIndex = index + 1;\n    if (nextIndex >= count) {\n      if (this.wrapFocus_) {\n        nextIndex = 0;\n      } else {\n        // Return early because last item is already focused.\n        return index;\n      }\n    }\n    this.adapter.focusItemAtIndex(nextIndex);\n\n    return nextIndex;\n  }\n\n  /**\n   * Focuses the previous element on the list.\n   */\n  focusPrevElement(index: number) {\n    let prevIndex = index - 1;\n    if (prevIndex < 0) {\n      if (this.wrapFocus_) {\n        prevIndex = this.adapter.getListItemCount() - 1;\n      } else {\n        // Return early because first item is already focused.\n        return index;\n      }\n    }\n    this.adapter.focusItemAtIndex(prevIndex);\n\n    return prevIndex;\n  }\n\n  focusFirstElement() {\n    this.adapter.focusItemAtIndex(0);\n    return 0;\n  }\n\n  focusLastElement() {\n    const lastIndex = this.adapter.getListItemCount() - 1;\n    this.adapter.focusItemAtIndex(lastIndex);\n    return lastIndex;\n  }\n\n  /**\n   * @param itemIndex Index of the list item\n   * @param isEnabled Sets the list item to enabled or disabled.\n   */\n  setEnabled(itemIndex: number, isEnabled: boolean): void {\n    if (!this.isIndexValid_(itemIndex)) {\n      return;\n    }\n\n    this.adapter.setDisabledStateForElementIndex(itemIndex, !isEnabled);\n  }\n\n  /**\n   * Ensures that preventDefault is only called if the containing element\n   * doesn't consume the event, and it will cause an unintended scroll.\n   */\n  private preventDefaultEvent(evt: KeyboardEvent) {\n    const target = evt.target as Element;\n    const tagName = `${target.tagName}`.toLowerCase();\n    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {\n      evt.preventDefault();\n    }\n  }\n\n  private setSingleSelectionAtIndex_(index: number, isInteraction = true) {\n    if (this.selectedIndex_ === index) {\n      return;\n    }\n\n    // unset previous\n    if (this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      this.adapter.setSelectedStateForElementIndex(\n          this.selectedIndex_ as number, false);\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(\n            this.selectedIndex_ as number, false);\n      }\n    }\n\n    // set new\n    if (isInteraction) {\n      this.adapter.setSelectedStateForElementIndex(index, true);\n    }\n    if (this.useActivatedClass_) {\n      this.adapter.setActivatedStateForElementIndex(index, true);\n    }\n    this.setAriaForSingleSelectionAtIndex_(index);\n\n    this.selectedIndex_ = index;\n\n    this.adapter.notifySelected(index);\n  }\n\n  private setMultiSelectionAtIndex_(\n      newIndex: Set<number>, isInteraction = true) {\n    const oldIndex = createSetFromIndex(this.selectedIndex_);\n    const diff = findIndexDiff(oldIndex, newIndex);\n\n    if (!diff.removed.length && !diff.added.length) {\n      return;\n    }\n\n    for (const removed of diff.removed) {\n      if (isInteraction) {\n        this.adapter.setSelectedStateForElementIndex(removed, false);\n      }\n\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(removed, false);\n      }\n    }\n\n    for (const added of diff.added) {\n      if (isInteraction) {\n        this.adapter.setSelectedStateForElementIndex(added, true);\n      }\n\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(added, true);\n      }\n    }\n\n    this.selectedIndex_ = newIndex;\n\n    this.adapter.notifySelected(newIndex, diff);\n  }\n\n  /**\n   * Sets aria attribute for single selection at given index.\n   */\n  private setAriaForSingleSelectionAtIndex_(index: number) {\n    // Detect the presence of aria-current and get the value only during list\n    // initialization when it is in unset state.\n    if (this.selectedIndex_ === numbers.UNSET_INDEX) {\n      this.ariaCurrentAttrValue_ =\n          this.adapter.getAttributeForElementIndex(index, strings.ARIA_CURRENT);\n    }\n\n    const isAriaCurrent = this.ariaCurrentAttrValue_ !== null;\n    const ariaAttribute =\n        isAriaCurrent ? strings.ARIA_CURRENT : strings.ARIA_SELECTED;\n\n    if (this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      this.adapter.setAttributeForElementIndex(\n          this.selectedIndex_ as number, ariaAttribute, 'false');\n    }\n\n    const ariaAttributeValue =\n        isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';\n    this.adapter.setAttributeForElementIndex(\n        index, ariaAttribute, ariaAttributeValue as string);\n  }\n\n  private setTabindexAtIndex_(index: number) {\n    if (this.focusedItemIndex_ === numbers.UNSET_INDEX && index !== 0) {\n      // If no list item was selected set first list item's tabindex to -1.\n      // Generally, tabindex is set to 0 on first list item of list that has no\n      // preselected items.\n      this.adapter.setTabIndexForElementIndex(0, -1);\n    } else if (\n        this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {\n      this.adapter.setTabIndexForElementIndex(this.focusedItemIndex_, -1);\n    }\n\n    this.adapter.setTabIndexForElementIndex(index, 0);\n  }\n\n  private setTabindexToFirstSelectedItem_() {\n    let targetIndex = 0;\n\n    if (typeof this.selectedIndex_ === 'number' &&\n        this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      targetIndex = this.selectedIndex_;\n    } else if (\n        isIndexSet(this.selectedIndex_) && this.selectedIndex_.size > 0) {\n      targetIndex = Math.min(...this.selectedIndex_);\n    }\n\n    this.setTabindexAtIndex_(targetIndex);\n  }\n\n  private isIndexValid_(index: MWCListIndex) {\n    if (index instanceof Set) {\n      if (!this.isMulti_) {\n        throw new Error(\n            'MDCListFoundation: Array of index is only supported for checkbox based list');\n      }\n\n      if (index.size === 0) {\n        return true;\n      } else {\n        let isOneInRange = false;\n\n        for (const entry of index) {\n          isOneInRange = this.isIndexInRange_(entry);\n\n          if (isOneInRange) {\n            break;\n          }\n        }\n\n        return isOneInRange;\n      }\n    } else if (typeof index === 'number') {\n      if (this.isMulti_) {\n        throw new Error(\n            'MDCListFoundation: Expected array of index for checkbox based list but got number: ' +\n            index);\n      }\n      return index === numbers.UNSET_INDEX || this.isIndexInRange_(index);\n    } else {\n      return false;\n    }\n  }\n\n  private isIndexInRange_(index: number) {\n    const listSize = this.adapter.getListItemCount();\n    return index >= 0 && index < listSize;\n  }\n\n  /**\n   * Sets selected index on user action, toggles checkbox / radio based on\n   * toggleCheckbox value. User interaction should not toggle list item(s) when\n   * disabled.\n   */\n  private setSelectedIndexOnAction_(\n      index: number, isInteraction: boolean, force?: boolean) {\n    if (this.adapter.getDisabledStateForElementIndex(index)) {\n      return;\n    }\n\n    let checkedIndex: MWCListIndex = index;\n\n    if (this.isMulti_) {\n      checkedIndex = new Set([index]);\n    }\n\n    if (!this.isIndexValid_(checkedIndex)) {\n      return;\n    }\n\n    if (this.isMulti_) {\n      this.toggleMultiAtIndex(index, force, isInteraction);\n    } else {\n      if (isInteraction || force) {\n        this.setSingleSelectionAtIndex_(index, isInteraction);\n      } else {\n        const isDeselection = this.selectedIndex_ === index;\n        if (isDeselection) {\n          this.setSingleSelectionAtIndex_(numbers.UNSET_INDEX);\n        }\n      }\n    }\n\n    if (isInteraction) {\n      this.adapter.notifyAction(index);\n    }\n  }\n\n  toggleMultiAtIndex(index: number, force?: boolean, isInteraction = true) {\n    let newSelectionValue = false;\n\n    if (force === undefined) {\n      newSelectionValue = !this.adapter.getSelectedStateForElementIndex(index);\n    } else {\n      newSelectionValue = force;\n    }\n\n    const newSet = createSetFromIndex(this.selectedIndex_);\n\n    if (newSelectionValue) {\n      newSet.add(index);\n    } else {\n      newSet.delete(index);\n    }\n\n    this.setMultiSelectionAtIndex_(newSet, isInteraction);\n  }\n}\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility\n// with MDC Web v0.44.0 and earlier.\nexport default MDCListFoundation;\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport './mwc-list-item.js';\n\nimport {BaseElement} from '@material/mwc-base/base-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {deepActiveElementPath, doesElementContainFocus, isNodeElement} from '@material/mwc-base/utils.js';\nimport {html} from 'lit';\nimport {property, query, queryAssignedNodes} from 'lit/decorators.js';\nimport {ifDefined} from 'lit/directives/if-defined.js';\n\nimport {MDCListAdapter} from './mwc-list-adapter.js';\nimport MDCListFoundation, {ActionDetail, isIndexSet, SelectedDetail} from './mwc-list-foundation.js';\nimport {MWCListIndex} from './mwc-list-foundation.js';\nimport {Layoutable, ListItemBase, RequestSelectedDetail} from './mwc-list-item-base.js';\n\nexport {ActionDetail, createSetFromIndex, isEventMulti, isIndexSet, MultiSelectedEvent, MWCListIndex, SelectedDetail, SelectedEvent, SingleSelectedEvent} from './mwc-list-foundation.js';\n\nfunction debounceLayout(\n    callback: (updateItems: boolean) => void, waitInMS = 50) {\n  let timeoutId: number;\n  // tslint:disable-next-line\n  return function(updateItems = true) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n                  callback(updateItems);\n                }, waitInMS) as unknown as number;\n  };\n}\n\nconst isListItem = (element: Element): element is ListItemBase => {\n  return element.hasAttribute('mwc-list-item');\n};\n\nfunction clearAndCreateItemsReadyPromise(this: ListBase) {\n  const oldResolver = this.itemsReadyResolver;\n  this.itemsReady = new Promise((res) => {\n    // TODO(b/175626389): Type '(value: never[] | PromiseLike<never[]>) => void'\n    // is not assignable to type '(value?: never[] | PromiseLike<never[]> |\n    // undefined) => void'.\n    return this.itemsReadyResolver = res as any;\n  });\n  oldResolver();\n}\n\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires items-updated\n */\nexport abstract class ListBase extends BaseElement implements Layoutable {\n  protected mdcFoundation!: MDCListFoundation;\n  protected mdcAdapter: MDCListAdapter|null = null;\n\n  protected readonly mdcFoundationClass = MDCListFoundation;\n\n  @property({type: String}) emptyMessage: string|undefined;\n\n  @query('.mdc-deprecated-list') protected mdcRoot!: HTMLElement;\n\n  @queryAssignedNodes('', true, '*')\n  protected assignedElements!: HTMLElement[]|null;\n  @queryAssignedNodes('', true, '[tabindex=\"0\"]')\n  protected tabbableElements!: HTMLElement[]|null;\n\n  @property({type: Boolean})\n  @observer(function(this: ListBase, value: boolean) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.setUseActivatedClass(value);\n    }\n  })\n  activatable = false;\n\n  @property({type: Boolean})\n  @observer(function(this: ListBase, newValue: boolean, oldValue: boolean) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.setMulti(newValue);\n    }\n\n    if (oldValue !== undefined) {\n      this.layout();\n    }\n  })\n  multi = false;\n\n  @property({type: Boolean})\n  @observer(function(this: ListBase, value: boolean) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.setWrapFocus(value);\n    }\n  })\n  wrapFocus = false;\n\n  @property({type: String})\n  @observer(function(this: ListBase, _newValue, oldValue: string|null) {\n    if (oldValue !== undefined) {\n      this.updateItems();\n    }\n  })\n  itemRoles: string|null = null;\n\n  @property({type: String}) innerRole: string|null = null;\n\n  @property({type: String}) innerAriaLabel: string|null = null;\n\n  @property({type: Boolean}) rootTabbable = false;\n\n  protected previousTabindex: Element|null = null;\n\n  @property({type: Boolean, reflect: true})\n  @observer(function(this: ListBase, value: boolean) {\n    if (value) {\n      const tabbable = this.tabbableElements?.[0] ?? null;\n      this.previousTabindex = tabbable;\n      if (tabbable) {\n        tabbable.setAttribute('tabindex', '-1');\n      }\n    } else if (!value && this.previousTabindex) {\n      this.previousTabindex.setAttribute('tabindex', '0');\n      this.previousTabindex = null;\n    }\n  })\n  noninteractive = false;\n\n  debouncedLayout: (updateItems?: boolean) => void | undefined;\n  protected itemsReadyResolver:\n      (value?: (PromiseLike<never[]>|never[]|undefined)) => void =\n          (() => {\n               //\n           }) as(value?: (PromiseLike<unknown[]>|unknown[])) => void;\n\n  constructor() {\n    super();\n    const debouncedFunction = debounceLayout(this.layout.bind(this));\n    this.debouncedLayout = (updateItems = true) => {\n      clearAndCreateItemsReadyPromise.call(this);\n\n      debouncedFunction(updateItems);\n    };\n  }\n\n  itemsReady = Promise.resolve([]);\n\n  // tslint:disable:ban-ts-ignore\n  protected override async getUpdateComplete() {\n    // @ts-ignore\n    const result = await super.getUpdateComplete();\n    await this.itemsReady;\n    return result;\n  }\n  // tslint:enable:ban-ts-ignore\n\n\n  protected items_: ListItemBase[] = [];\n\n  get items(): ListItemBase[] {\n    return this.items_;\n  }\n\n  protected updateItems() {\n    const nodes = this.assignedElements ?? [];\n    const listItems: ListItemBase[] = [];\n\n    for (const node of nodes) {\n      if (isListItem(node)) {\n        listItems.push(node);\n        node._managingList = this;\n      }\n\n      if (node.hasAttribute('divider') && !node.hasAttribute('role')) {\n        node.setAttribute('role', 'separator');\n      }\n    }\n\n    this.items_ = listItems;\n    const selectedIndices = new Set<number>();\n\n    this.items_.forEach((item, index) => {\n      if (this.itemRoles) {\n        item.setAttribute('role', this.itemRoles);\n      } else {\n        item.removeAttribute('role');\n      }\n\n      if (item.selected) {\n        selectedIndices.add(index);\n      }\n    });\n\n    if (this.multi) {\n      this.select(selectedIndices);\n    } else {\n      const index =\n          selectedIndices.size ? selectedIndices.entries().next().value[1] : -1;\n      this.select(index);\n    }\n\n    const itemsUpdatedEv =\n        new Event('items-updated', {bubbles: true, composed: true});\n    this.dispatchEvent(itemsUpdatedEv);\n  }\n\n  get selected(): ListItemBase|ListItemBase[]|null {\n    const index = this.index;\n\n    if (!isIndexSet(index)) {\n      if (index === -1) {\n        return null;\n      }\n\n      return this.items[index];\n    }\n\n    const selected: ListItemBase[] = [];\n\n    for (const entry of index) {\n      selected.push(this.items[entry]);\n    }\n\n    return selected;\n  }\n\n  get index(): MWCListIndex {\n    if (this.mdcFoundation) {\n      return this.mdcFoundation.getSelectedIndex();\n    }\n\n    return -1;\n  }\n\n  override render() {\n    const role = this.innerRole === null ? undefined : this.innerRole;\n    const ariaLabel =\n        this.innerAriaLabel === null ? undefined : this.innerAriaLabel;\n    const tabindex = this.rootTabbable ? '0' : '-1';\n\n    return html`\n      <!-- @ts-ignore -->\n      <ul\n          tabindex=${tabindex}\n          role=\"${ifDefined(role)}\"\n          aria-label=\"${ifDefined(ariaLabel)}\"\n          class=\"mdc-deprecated-list\"\n          @keydown=${this.onKeydown}\n          @focusin=${this.onFocusIn}\n          @focusout=${this.onFocusOut}\n          @request-selected=${this.onRequestSelected}\n          @list-item-rendered=${this.onListItemConnected}>\n        <slot></slot>\n        ${this.renderPlaceholder()}\n      </ul>\n    `;\n  }\n\n  renderPlaceholder() {\n    const nodes = this.assignedElements ?? [];\n    if (this.emptyMessage !== undefined && nodes.length === 0) {\n      return html`\n        <mwc-list-item noninteractive>${this.emptyMessage}</mwc-list-item>\n      `;\n    }\n\n    return null;\n  }\n\n  override firstUpdated() {\n    super.firstUpdated();\n\n    if (!this.items.length) {\n      // required because this is called before observers\n      this.mdcFoundation.setMulti(this.multi);\n      // for when children upgrade before list\n      this.layout();\n    }\n  }\n\n  protected onFocusIn(evt: FocusEvent) {\n    if (this.mdcFoundation && this.mdcRoot) {\n      const index = this.getIndexOfTarget(evt);\n      this.mdcFoundation.handleFocusIn(evt, index);\n    }\n  }\n\n  protected onFocusOut(evt: FocusEvent) {\n    if (this.mdcFoundation && this.mdcRoot) {\n      const index = this.getIndexOfTarget(evt);\n      this.mdcFoundation.handleFocusOut(evt, index);\n    }\n  }\n\n  protected onKeydown(evt: KeyboardEvent) {\n    if (this.mdcFoundation && this.mdcRoot) {\n      const index = this.getIndexOfTarget(evt);\n      const target = evt.target as Element;\n      const isRootListItem = isListItem(target);\n      this.mdcFoundation.handleKeydown(evt, isRootListItem, index);\n    }\n  }\n\n  protected onRequestSelected(evt: CustomEvent<RequestSelectedDetail>) {\n    if (this.mdcFoundation) {\n      let index = this.getIndexOfTarget(evt);\n\n      // might happen in shady dom slowness. Recalc children\n      if (index === -1) {\n        this.layout();\n        index = this.getIndexOfTarget(evt);\n\n        // still not found; may not be mwc-list-item. Unsupported case.\n        if (index === -1) {\n          return;\n        }\n      }\n\n      const element = this.items[index];\n\n      if (element.disabled) {\n        return;\n      }\n\n      const selected = evt.detail.selected;\n      const source = evt.detail.source;\n\n      this.mdcFoundation.handleSingleSelection(\n          index, source === 'interaction', selected);\n\n      evt.stopPropagation();\n    }\n  }\n\n  protected getIndexOfTarget(evt: Event): number {\n    const elements = this.items;\n    const path = evt.composedPath();\n\n    for (const pathItem of path as Node[]) {\n      let index = -1;\n      if (isNodeElement(pathItem) && isListItem(pathItem)) {\n        index = elements.indexOf(pathItem);\n      }\n\n      if (index !== -1) {\n        return index;\n      }\n    }\n\n    return -1;\n  }\n\n  protected createAdapter(): MDCListAdapter {\n    this.mdcAdapter = {\n      getListItemCount: () => {\n        if (this.mdcRoot) {\n          return this.items.length;\n        }\n\n        return 0;\n      },\n      getFocusedElementIndex: this.getFocusedItemIndex,\n      getAttributeForElementIndex: (index, attr) => {\n        const listElement = this.mdcRoot;\n        if (!listElement) {\n          return '';\n        }\n\n        const element = this.items[index];\n        return element ? element.getAttribute(attr) : '';\n      },\n      setAttributeForElementIndex: (index, attr, val) => {\n        if (!this.mdcRoot) {\n          return;\n        }\n\n        const element = this.items[index];\n\n        if (element) {\n          element.setAttribute(attr, val);\n        }\n      },\n      focusItemAtIndex: (index) => {\n        const element = this.items[index];\n        if (element) {\n          element.focus();\n        }\n      },\n      setTabIndexForElementIndex: (index, value) => {\n        const item = this.items[index];\n\n        if (item) {\n          item.tabindex = value;\n        }\n      },\n      notifyAction: (index) => {\n        const init: CustomEventInit = {bubbles: true, composed: true};\n        init.detail = {index};\n        const ev = new CustomEvent<ActionDetail>('action', init);\n        this.dispatchEvent(ev);\n      },\n      notifySelected: (index, diff) => {\n        const init: CustomEventInit = {bubbles: true, composed: true};\n        init.detail = {index, diff};\n        const ev = new CustomEvent<SelectedDetail>('selected', init);\n        this.dispatchEvent(ev);\n      },\n      isFocusInsideList: () => {\n        return doesElementContainFocus(this);\n      },\n      isRootFocused: () => {\n        const mdcRoot = this.mdcRoot;\n        const root = mdcRoot.getRootNode() as unknown as DocumentOrShadowRoot;\n        return root.activeElement === mdcRoot;\n      },\n      setDisabledStateForElementIndex: (index, value) => {\n        const item = this.items[index];\n\n        if (!item) {\n          return;\n        }\n\n        item.disabled = value;\n      },\n      getDisabledStateForElementIndex: (index) => {\n        const item = this.items[index];\n\n        if (!item) {\n          return false;\n        }\n\n        return item.disabled;\n      },\n      setSelectedStateForElementIndex: (index, value) => {\n        const item = this.items[index];\n\n        if (!item) {\n          return;\n        }\n\n        item.selected = value;\n      },\n      getSelectedStateForElementIndex: (index) => {\n        const item = this.items[index];\n\n        if (!item) {\n          return false;\n        }\n\n        return item.selected;\n      },\n      setActivatedStateForElementIndex: (index, value) => {\n        const item = this.items[index];\n\n        if (!item) {\n          return;\n        }\n\n        item.activated = value;\n      },\n    };\n\n    return this.mdcAdapter;\n  }\n\n  protected selectUi(index: number, activate = false) {\n    const item = this.items[index];\n    if (item) {\n      item.selected = true;\n      item.activated = activate;\n    }\n  }\n\n  protected deselectUi(index: number) {\n    const item = this.items[index];\n    if (item) {\n      item.selected = false;\n      item.activated = false;\n    }\n  }\n\n  select(index: MWCListIndex) {\n    if (!this.mdcFoundation) {\n      return;\n    }\n\n    this.mdcFoundation.setSelectedIndex(index);\n  }\n\n  toggle(index: number, force?: boolean) {\n    if (this.multi) {\n      this.mdcFoundation.toggleMultiAtIndex(index, force);\n    }\n  }\n\n  protected onListItemConnected(e: CustomEvent) {\n    const target = e.target as ListItemBase;\n\n    this.layout(this.items.indexOf(target) === -1);\n  }\n\n  layout(updateItems = true) {\n    if (updateItems) {\n      this.updateItems();\n    }\n\n    const first: ListItemBase|undefined = this.items[0];\n\n    for (const item of this.items) {\n      item.tabindex = -1;\n    }\n\n    if (first) {\n      if (this.noninteractive) {\n        if (!this.previousTabindex) {\n          this.previousTabindex = first;\n        }\n      } else {\n        first.tabindex = 0;\n      }\n    }\n\n    this.itemsReadyResolver();\n  }\n\n  getFocusedItemIndex() {\n    if (!this.mdcRoot) {\n      return -1;\n    }\n\n    if (!this.items.length) {\n      return -1;\n    }\n\n    const activeElementPath = deepActiveElementPath();\n\n    if (!activeElementPath.length) {\n      return -1;\n    }\n\n    for (let i = activeElementPath.length - 1; i >= 0; i--) {\n      const activeItem = activeElementPath[i];\n\n      if (isListItem(activeItem)) {\n        return this.items.indexOf(activeItem);\n      }\n    }\n\n    return -1;\n  }\n\n  focusItemAtIndex(index: number) {\n    for (const item of this.items) {\n      if (item.tabindex === 0) {\n        item.tabindex = -1;\n        break;\n      }\n    }\n\n    this.items[index].tabindex = 0;\n    this.items[index].focus();\n  }\n\n  override focus() {\n    const root = this.mdcRoot;\n\n    if (root) {\n      root.focus();\n    }\n  }\n\n  override blur() {\n    const root = this.mdcRoot;\n\n    if (root) {\n      root.blur();\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-LIcense-Identifier: Apache-2.0\n */\nimport {css} from 'lit';\nexport const styles = css`@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}:host{display:block}.mdc-deprecated-list{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size, 1rem);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height, 1.75rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight, 400);letter-spacing:0.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing, 0.009375em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform, inherit);line-height:1.5rem;margin:0;padding:8px 0;list-style-type:none;color:rgba(0, 0, 0, 0.87);color:var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87));padding:var(--mdc-list-vertical-padding, 8px) 0}.mdc-deprecated-list:focus{outline:none}.mdc-deprecated-list-item{height:48px}.mdc-deprecated-list--dense{padding-top:4px;padding-bottom:4px;font-size:.812rem}.mdc-deprecated-list ::slotted([divider]){height:0;margin:0;border:none;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgba(0, 0, 0, 0.12)}.mdc-deprecated-list ::slotted([divider][padded]){margin:0 var(--mdc-list-side-padding, 16px)}.mdc-deprecated-list ::slotted([divider][inset]){margin-left:var(--mdc-list-inset-margin, 72px);margin-right:0;width:calc( 100% - var(--mdc-list-inset-margin, 72px) )}[dir=rtl] .mdc-deprecated-list ::slotted([divider][inset]),.mdc-deprecated-list ::slotted([divider][inset][dir=rtl]){margin-left:0;margin-right:var(--mdc-list-inset-margin, 72px)}.mdc-deprecated-list ::slotted([divider][inset][padded]){width:calc( 100% - var(--mdc-list-inset-margin, 72px) - var(--mdc-list-side-padding, 16px) )}.mdc-deprecated-list--dense ::slotted([mwc-list-item]){height:40px}.mdc-deprecated-list--dense ::slotted([mwc-list]){--mdc-list-item-graphic-size: 20px}.mdc-deprecated-list--two-line.mdc-deprecated-list--dense ::slotted([mwc-list-item]),.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense ::slotted([mwc-list-item]){height:60px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense ::slotted([mwc-list]){--mdc-list-item-graphic-size: 36px}:host([noninteractive]){pointer-events:none;cursor:default}.mdc-deprecated-list--dense ::slotted(.mdc-deprecated-list-item__primary-text){display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-deprecated-list--dense ::slotted(.mdc-deprecated-list-item__primary-text)::before{display:inline-block;width:0;height:24px;content:\"\";vertical-align:0}.mdc-deprecated-list--dense ::slotted(.mdc-deprecated-list-item__primary-text)::after{display:inline-block;width:0;height:20px;content:\"\";vertical-align:-20px}`;\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"],"names":["ListItem","_ListItemBase","_classCallCheck","_callSuper","arguments","_inherits","_createClass","ListItemBase","styles","__decorate","customElement","KEY","normalizedKeys","Set","add","KEY_CODE","mappedKeyCodes","Map","set","_a","_b","navigationKeys","normalizeKey","evt","key","has","mappedKey","get","keyCode","cssClasses","deprecatedClassNameMap","strings","ACTION_EVENT","SELECTION_CHANGE_EVENT","ARIA_CHECKED","ARIA_CHECKED_CHECKBOX_SELECTOR","ARIA_CHECKED_RADIO_SELECTOR","ARIA_CURRENT","ARIA_DISABLED","ARIA_ORIENTATION","ARIA_ORIENTATION_HORIZONTAL","ARIA_ROLE_CHECKBOX_SELECTOR","ARIA_SELECTED","ARIA_INTERACTIVE_ROLES_SELECTOR","ARIA_MULTI_SELECTABLE_SELECTOR","CHECKBOX_RADIO_SELECTOR","CHECKBOX_SELECTOR","CHILD_ELEMENTS_TO_TOGGLE_TABINDEX","DEPRECATED_SELECTOR","FOCUSABLE_CHILD_ELEMENTS","RADIO_SELECTOR","SELECTED_ITEM_SELECTOR","numbers","UNSET_INDEX","TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS","integerSort","a","b","ELEMENTS_KEY_ALLOWED_IN","isIndexSet","selectedIndex","createSetFromIndex","index","entry","MDCListFoundation","_MDCFoundation","adapter","_this","Object","assign","defaultAdapter","isMulti_","wrapFocus_","isVertical_","selectedIndex_","focusedItemIndex_","useActivatedClass_","ariaCurrentAttrValue_","value","this","currentIndex","isUnset","size","vals","Array","from","sort","useActivated","isIndexValid_","setMultiSelectionAtIndex_","setSingleSelectionAtIndex_","_","listItemIndex","setTabIndexForElementIndex","_this2","setTimeout","isFocusInsideList","setTabindexToFirstSelectedItem_","event","isRootListItem","isArrowLeft","isArrowUp","isArrowRight","isArrowDown","isHome","isEnd","isEnter","isSpace","isRootFocused","preventDefault","focusLastElement","focusFirstElement","getFocusedElementIndex","nextIndex","preventDefaultEvent","focusNextElement","focusPrevElement","target","tagName","setSelectedIndexOnAction_","undefined","setTabindexAtIndex_","isInteraction","force","getListItemCount","focusItemAtIndex","prevIndex","lastIndex","itemIndex","isEnabled","setDisabledStateForElementIndex","concat","toLowerCase","indexOf","length","setSelectedStateForElementIndex","setActivatedStateForElementIndex","setAriaForSingleSelectionAtIndex_","notifySelected","newIndex","diff","oldSet","newSet","oldArr","newArr","added","removed","oldSorted","newSorted","i","j","oldVal","newVal","push","findIndexDiff","_step","_iterator","_createForOfIteratorHelper","s","n","done","err","e","f","_step2","_iterator2","getAttributeForElementIndex","isAriaCurrent","ariaAttribute","setAttributeForElementIndex","ariaAttributeValue","targetIndex","Math","min","apply","_toConsumableArray","Error","_step3","isOneInRange","_iterator3","isIndexInRange_","listSize","getDisabledStateForElementIndex","checkedIndex","toggleMultiAtIndex","notifyAction","newSelectionValue","getSelectedStateForElementIndex","delete","MDCFoundation","isListItem","element","hasAttribute","clearAndCreateItemsReadyPromise","oldResolver","itemsReadyResolver","itemsReady","Promise","res","ListBase","_BaseElement","mdcAdapter","mdcFoundationClass","activatable","multi","wrapFocus","itemRoles","innerRole","innerAriaLabel","rootTabbable","previousTabindex","noninteractive","resolve","items_","debouncedFunction","callback","timeoutId","waitInMS","updateItems","clearTimeout","debounceLayout","layout","bind","debouncedLayout","call","_getUpdateComplete","_asyncToGenerator","_regenerator","m","_callee","result","w","_context","_superPropGet","v","_this3","nodes","assignedElements","listItems","node","_managingList","setAttribute","selectedIndices","forEach","item","removeAttribute","selected","select","entries","next","itemsUpdatedEv","Event","bubbles","composed","dispatchEvent","items","mdcFoundation","getSelectedIndex","role","ariaLabel","tabindex","html","_templateObject","_taggedTemplateLiteral","ifDefined","onKeydown","onFocusIn","onFocusOut","onRequestSelected","onListItemConnected","renderPlaceholder","emptyMessage","_templateObject2","setMulti","mdcRoot","getIndexOfTarget","handleFocusIn","handleFocusOut","handleKeydown","disabled","detail","source","handleSingleSelection","stopPropagation","elements","path","composedPath","pathItem","isNodeElement","_this4","getFocusedItemIndex","attr","getAttribute","val","focus","init","ev","CustomEvent","doesElementContainFocus","getRootNode","activeElement","activated","activate","setSelectedIndex","_step4","first","_iterator4","activeElementPath","deepActiveElementPath","activeItem","_step5","_iterator5","root","blur","BaseElement","property","type","String","query","queryAssignedElements","flatten","selector","Boolean","observer","setUseActivatedClass","newValue","oldValue","setWrapFocus","_newValue","reflect","tabbable","tabbableElements","css","r","l","t","c","_t","_class","o","values","keys","dt","_ref","_this$ut","_ref2","_slicedToArray","d","_this$dt","p","isArray","ut","y","h","x","k","u"],"mappings":"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"}