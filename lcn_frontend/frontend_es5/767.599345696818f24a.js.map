{"version":3,"file":"767.599345696818f24a.js","sources":["webpack://lcn-frontend/./node_modules/@lit-labs/virtualizer/src/LitVirtualizer.ts","webpack://lcn-frontend/./node_modules/@lit-labs/virtualizer/src/ScrollerController.ts","webpack://lcn-frontend/./node_modules/@lit-labs/virtualizer/src/Virtualizer.ts","webpack://lcn-frontend/./node_modules/@lit-labs/virtualizer/src/events.ts","webpack://lcn-frontend/./node_modules/@lit-labs/virtualizer/src/lit-virtualizer.ts","webpack://lcn-frontend/./node_modules/@lit-labs/virtualizer/src/virtualize.ts","webpack://lcn-frontend/./node_modules/lit-html/src/async-directive.ts","webpack://lcn-frontend/./node_modules/lit-html/src/directives/repeat.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {html, LitElement} from 'lit';\nimport {property} from 'lit/decorators/property.js';\nimport {KeyFn} from 'lit/directives/repeat.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\nimport {\n  virtualize,\n  virtualizerRef,\n  VirtualizerHostElement,\n  defaultRenderItem,\n  defaultKeyFunction,\n  RenderItemFunction,\n} from './virtualize.js';\n\nexport class LitVirtualizer<T = unknown> extends LitElement {\n  @property({attribute: false})\n  items: T[] = [];\n\n  @property()\n  renderItem: RenderItemFunction<T> = defaultRenderItem;\n\n  @property()\n  keyFunction: KeyFn<T> = defaultKeyFunction;\n\n  @property({attribute: false})\n  layout: LayoutConfigValue = {};\n\n  @property({reflect: true, type: Boolean})\n  scroller = false;\n\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    const {items, renderItem, keyFunction, layout, scroller} = this;\n    return html`${virtualize({\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller,\n    })}`;\n  }\n\n  element(index: number) {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.element(index);\n  }\n\n  get layoutComplete() {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.layoutComplete;\n  }\n\n  /**\n   * This scrollToIndex() shim is here to provide backwards compatibility with other 0.x versions of\n   * lit-virtualizer. It is deprecated and will likely be removed in the 1.0.0 release.\n   */\n  scrollToIndex(\n    index: number,\n    position: 'start' | 'center' | 'end' | 'nearest' = 'start'\n  ) {\n    this.element(index)?.scrollIntoView({block: position});\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ScrollToCoordinates} from './layouts/shared/Layout.js';\n\ntype retargetScrollCallback = () => ScrollToCoordinates;\ntype endScrollCallback = () => void;\ntype Nullable<T> = T | null;\n\nexport class ScrollerShim {\n  protected _node: Element | Window;\n  protected _element: Nullable<Element> = null;\n\n  constructor(element?: Element) {\n    const node = element ?? window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n\n  public get element() {\n    return (\n      this._element || document.scrollingElement || document.documentElement\n    );\n  }\n\n  public get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n\n  public get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n\n  public get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n\n  public get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n\n  public get viewportHeight() {\n    return this._element\n      ? this._element.getBoundingClientRect().height\n      : window.innerHeight;\n  }\n\n  public get viewportWidth() {\n    return this._element\n      ? this._element.getBoundingClientRect().width\n      : window.innerWidth;\n  }\n\n  public get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n\n  public get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\n\nexport class ScrollerController extends ScrollerShim {\n  private _originalScrollTo:\n    | typeof Element.prototype.scrollTo\n    | typeof window.scrollTo;\n  private _originalScrollBy:\n    | typeof Element.prototype.scrollBy\n    | typeof window.scrollBy;\n  private _originalScroll:\n    | typeof Element.prototype.scroll\n    | typeof window.scroll;\n  private _clients = new Set<unknown>();\n  private _retarget: Nullable<retargetScrollCallback> = null;\n  private _end: Nullable<endScrollCallback> = null;\n  private __destination: Nullable<ScrollToOptions> = null;\n\n  constructor(client: unknown, element?: Element) {\n    super(element);\n\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n\n    const node = this._node;\n\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n\n  public correctingScrollError = false;\n\n  private get _destination() {\n    return this.__destination;\n  }\n\n  public get scrolling() {\n    return this._destination !== null;\n  }\n\n  public scrollTo(options: ScrollToOptions): void;\n  public scrollTo(x: number, y: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    this._scrollTo(options);\n  }\n\n  public scrollBy(options: ScrollToOptions): void;\n  public scrollBy(x: number, y: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n\n  private _nativeScrollTo(options: ScrollToOptions) {\n    this._originalScrollTo!.bind(this._element || window)(options);\n  }\n\n  private _scrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback | null = null,\n    end: endScrollCallback | null = null\n  ) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n\n  private _setDestination(options: ScrollToOptions) {\n    let {top, left} = options;\n    top =\n      top === undefined\n        ? undefined\n        : Math.max(0, Math.min(top, this.maxScrollTop));\n    left =\n      left === undefined\n        ? undefined\n        : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (\n      this._destination !== null &&\n      left === this._destination.left &&\n      top === this._destination.top\n    ) {\n      return false;\n    }\n    this.__destination = {top, left, behavior: 'smooth'};\n    return true;\n  }\n\n  private _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n\n  private _updateManagedScrollTo(coordinates: ScrollToCoordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n\n  public managedScrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback,\n    end: endScrollCallback\n  ) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n\n  public correctScrollError(coordinates: ScrollToCoordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() =>\n      requestAnimationFrame(() => (this.correctingScrollError = false))\n    );\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n\n  private _checkForArrival() {\n    if (this._destination !== null) {\n      const {scrollTop, scrollLeft} = this;\n      let {top, left} = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n\n  public detach(client: unknown) {\n    this._clients.delete(client);\n\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n\n  private _attach(client: unknown) {\n    this._clients.add(client);\n\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client â€“ otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ItemBox,\n  Margins,\n  LayoutConfigValue,\n  ChildPositions,\n  ChildMeasurements,\n  Layout,\n  LayoutConstructor,\n  LayoutSpecifier,\n  StateChangedMessage,\n  Size,\n  InternalRange,\n  MeasureChildFunction,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  LayoutHostMessage,\n} from './layouts/shared/Layout.js';\nimport {\n  RangeChangedEvent,\n  VisibilityChangedEvent,\n  UnpinnedEvent,\n} from './events.js';\nimport {ScrollerController} from './ScrollerController.js';\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver: typeof ResizeObserver | undefined =\n  typeof window !== 'undefined' ? window.ResizeObserver : undefined;\n\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor: typeof ResizeObserver) {\n  _ResizeObserver = Ctor;\n}\n\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    rangeChanged: RangeChangedEvent;\n    visibilityChanged: VisibilityChangedEvent;\n    unpinned: UnpinnedEvent;\n  }\n}\n\nexport interface VirtualizerHostElement extends HTMLElement {\n  [virtualizerRef]?: Virtualizer;\n}\n\n/**\n * A very limited proxy object for a virtualizer child,\n * returned by Virtualizer.element(idx: number). Introduced\n * to enable scrolling a virtual element into view using\n * a call that looks and behaves essentially the same as for\n * a real Element. May be useful for other things later.\n */\nexport interface VirtualizerChildElementProxy {\n  scrollIntoView: (options?: ScrollIntoViewOptions) => void;\n}\n\n/**\n * Used internally for scrolling a (possibly virtual) element\n * into view, given its index\n */\ninterface ScrollElementIntoViewOptions extends ScrollIntoViewOptions {\n  index: number;\n}\n\nexport interface VirtualizerConfig {\n  layout?: LayoutConfigValue;\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n  hostElement: VirtualizerHostElement;\n\n  scroller?: boolean;\n}\n\nlet DefaultLayoutConstructor: LayoutConstructor;\n\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  private _benchmarkStart: number | null = null;\n\n  private _layout: Layout | null = null;\n\n  private _clippingAncestors: HTMLElement[] = [];\n\n  /**\n   * Layout provides these values, we set them on _render().\n   * TODO @straversi: Can we find an XOR type, usable for the key here?\n   */\n  private _scrollSize: Size | null = null;\n\n  /**\n   * Difference between scroll target's current and required scroll offsets.\n   * Provided by layout.\n   */\n  private _scrollError: {left: number; top: number} | null = null;\n\n  /**\n   * A list of the positions (top, left) of the children in the current range.\n   */\n  private _childrenPos: ChildPositions | null = null;\n\n  // TODO: (graynorton): type\n  private _childMeasurements: ChildMeasurements | null = null;\n\n  private _toBeMeasured = new Map<HTMLElement, unknown>();\n\n  private _rangeChanged = true;\n\n  private _itemsChanged = true;\n\n  private _visibilityChanged = true;\n\n  /**\n   * The HTMLElement that hosts the virtualizer. Set by hostElement.\n   */\n  protected _hostElement?: VirtualizerHostElement;\n\n  private _scrollerController: ScrollerController | null = null;\n\n  private _isScroller = false;\n\n  private _sizer: HTMLElement | null = null;\n\n  /**\n   * Resize observer attached to hostElement.\n   */\n  private _hostElementRO: ResizeObserver | null = null;\n\n  /**\n   * Resize observer attached to children.\n   */\n  private _childrenRO: ResizeObserver | null = null;\n\n  private _mutationObserver: MutationObserver | null = null;\n\n  private _scrollEventListeners: (Element | Window)[] = [];\n  private _scrollEventListenerOptions: AddEventListenerOptions = {\n    passive: true,\n  };\n\n  // TODO (graynorton): Rethink, per longer comment below\n\n  private _loadListener = this._childLoaded.bind(this);\n\n  /**\n   * Index of element to scroll into view, plus scroll\n   * behavior options, as imperatively specified via\n   * `element(index).scrollIntoView()`\n   */\n  private _scrollIntoViewTarget: ScrollElementIntoViewOptions | null = null;\n\n  private _updateScrollIntoViewCoordinates:\n    | ((coordinates: ScrollToCoordinates) => void)\n    | null = null;\n\n  /**\n   * Items to render. Set by items.\n   */\n  private _items: Array<unknown> = [];\n\n  /**\n   * Index of the first child in the range, not necessarily the first visible child.\n   * TODO @straversi: Consider renaming these.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child in the range.\n   */\n  protected _last = -1;\n\n  /**\n   * Index of the first item intersecting the viewport.\n   */\n  private _firstVisible = -1;\n\n  /**\n   * Index of the last item intersecting the viewport.\n   */\n  private _lastVisible = -1;\n\n  protected _scheduled = new WeakSet<Function>();\n\n  /**\n   * Invoked at the end of each render cycle: children in the range are\n   * measured, and their dimensions passed to this callback. Use it to layout\n   * children as needed.\n   */\n  protected _measureCallback: ((sizes: ChildMeasurements) => void) | null =\n    null;\n\n  protected _measureChildOverride: MeasureChildFunction | null = null;\n\n  /**\n   * State for `layoutComplete` promise\n   */\n  private _layoutCompletePromise: Promise<void> | null = null;\n  private _layoutCompleteResolver: Function | null = null;\n  private _layoutCompleteRejecter: Function | null = null;\n  private _pendingLayoutComplete: number | null = null;\n\n  /**\n   * Layout initialization is async because we dynamically load\n   * the default layout if none is specified. This state is to track\n   * whether init is complete.\n   */\n  private _layoutInitialized: Promise<void> | null = null;\n\n  /**\n   * Track connection state to guard against errors / unnecessary work\n   */\n  private _connected = false;\n\n  constructor(config: VirtualizerConfig) {\n    if (!config) {\n      throw new Error(\n        'Virtualizer constructor requires a configuration object'\n      );\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error(\n        'Virtualizer configuration requires the \"hostElement\" property'\n      );\n    }\n  }\n\n  set items(items: Array<unknown> | undefined) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config: VirtualizerConfig) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || ({} as BaseLayoutConfig);\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n\n  private _initObservers() {\n    this._mutationObserver = new MutationObserver(\n      this._finishDOMUpdate.bind(this)\n    );\n    this._hostElementRO = new _ResizeObserver!(() =>\n      this._hostElementSizeChanged()\n    );\n    this._childrenRO = new _ResizeObserver!(\n      this._childrenSizeChanged.bind(this)\n    );\n  }\n\n  _initHostElement(config: VirtualizerConfig) {\n    const hostElement = (this._hostElement = config.hostElement);\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(\n      this._hostElement!,\n      includeSelf\n    );\n\n    this._scrollerController = new ScrollerController(\n      this,\n      this._clippingAncestors[0]\n    );\n\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n    this._connected = true;\n  }\n\n  _observeAndListen() {\n    this._mutationObserver!.observe(this._hostElement!, {childList: true});\n    this._hostElementRO!.observe(this._hostElement!);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach((ancestor) => {\n      ancestor.addEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      );\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO!.observe(ancestor);\n    });\n    this._hostElementRO!.observe(this._scrollerController!.element);\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._scrollEventListeners.forEach((target) =>\n      target.addEventListener('scroll', this, this._scrollEventListenerOptions)\n    );\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach((target) =>\n      target.removeEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      )\n    );\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController?.detach(this);\n    this._scrollerController = null;\n    this._mutationObserver?.disconnect();\n    this._mutationObserver = null;\n    this._hostElementRO?.disconnect();\n    this._hostElementRO = null;\n    this._childrenRO?.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n    this._connected = false;\n  }\n\n  private _applyVirtualizerStyles() {\n    const hostElement = this._hostElement!;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style as CSSStyleDeclaration & {contain: string};\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement!;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(\n        `[${SIZER_ATTRIBUTE}]`\n      ) as HTMLElement;\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px',\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n\n  async updateLayoutConfig(layoutConfig: LayoutConfigValue) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor =\n      ((layoutConfig as LayoutSpecifier).type as LayoutConstructor) ||\n      // The new config is compatible with the current layout,\n      // so we update the config and return true to indicate\n      // a successful update\n      DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete config.type;\n      this._layout.config = config as BaseLayoutConfig;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n\n  private async _initLayout(layoutConfig: LayoutConfigValue) {\n    let config: BaseLayoutConfig | undefined;\n    let Ctor: LayoutConstructor | undefined;\n    if (typeof (layoutConfig as LayoutSpecifier).type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = (layoutConfig as LayoutSpecifier).type as LayoutConstructor;\n      // ...while the rest of the specifier is our layout config\n      const copy = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete copy.type;\n      config = copy as BaseLayoutConfig;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig as BaseLayoutConfig;\n    }\n\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n        .FlowLayout as unknown as LayoutConstructor;\n    }\n\n    this._layout = new Ctor(\n      (message: LayoutHostMessage) => this._handleLayoutMessage(message),\n      config\n    );\n\n    if (\n      this._layout.measureChildren &&\n      typeof this._layout.updateItemSizes === 'function'\n    ) {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement!.addEventListener('load', this._loadListener, true);\n    }\n\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName(\n        'uv-virtualizing',\n        'measure'\n      );\n      const virtualizationTime = entries\n        .filter(\n          (e) => e.startTime >= this._benchmarkStart! && e.startTime < now\n        )\n        .reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {timeElapsed, virtualizationTime};\n    }\n    return null;\n  }\n\n  private _measureChildren(): void {\n    const mm: ChildMeasurements = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element: Element): ItemBox {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {width, height} = element.getBoundingClientRect();\n    return Object.assign({width, height}, getMargins(element));\n  }\n\n  protected async _schedule(method: Function): Promise<void> {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n\n  async _updateDOM(state: StateChangedMessage) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {_rangeChanged, _itemsChanged} = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n\n  _finishDOMUpdate() {\n    if (this._connected) {\n      // _childrenRO should be non-null if we're connected\n      this._children.forEach((child) => this._childrenRO!.observe(child));\n      this._checkScrollIntoViewTarget(this._childrenPos);\n      this._positionChildren(this._childrenPos);\n      this._sizeHostElement(this._scrollSize);\n      this._correctScrollError();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  _updateLayout() {\n    if (this._layout && this._connected) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  private _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController!.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      this._layout?.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event: CustomEvent) {\n    switch (event.type) {\n      case 'scroll':\n        if (\n          event.currentTarget === window ||\n          this._clippingAncestors.includes(event.currentTarget as HTMLElement)\n        ) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  _handleLayoutMessage(message: LayoutHostMessage) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement!.dispatchEvent(new UnpinnedEvent());\n    }\n  }\n\n  get _children(): Array<HTMLElement> {\n    const arr: Array<HTMLElement> = [];\n    let next = this._hostElement!.firstElementChild as HTMLElement;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling as HTMLElement;\n    }\n    return arr;\n  }\n\n  private _updateView() {\n    const hostElement = this._hostElement;\n    const scrollingElement = this._scrollerController?.element;\n    const layout = this._layout;\n\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n\n      const hostElementBounds = hostElement.getBoundingClientRect();\n\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n\n      const ancestorBounds = this._clippingAncestors.map((ancestor) =>\n        ancestor.getBoundingClientRect()\n      );\n      ancestorBounds.unshift(hostElementBounds);\n\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top,\n      };\n\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight,\n      };\n\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n\n      const height = Math.max(0, bottom - top);\n      const width = Math.max(0, right - left);\n\n      layout.viewportSize = {width, height};\n      layout.viewportScroll = {top: scrollTop, left: scrollLeft};\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  private _sizeHostElement(size?: Size | null) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement!.style;\n      (style.minWidth as string | null) = h ? `${h}px` : '100%';\n      (style.minHeight as string | null) = v ? `${v}px` : '100%';\n    }\n  }\n\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  private _positionChildren(pos: ChildPositions | null) {\n    if (pos) {\n      pos.forEach(({top, left, width, height, xOffset, yOffset}, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          (child.style.left as string | null) =\n            xOffset === undefined ? null : xOffset + 'px';\n          (child.style.top as string | null) =\n            yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  private async _adjustRange(range: InternalRange) {\n    const {_first, _last, _firstVisible, _lastVisible} = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged =\n      this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged =\n      this._visibilityChanged ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible;\n  }\n\n  private _correctScrollError() {\n    if (this._scrollError) {\n      const {scrollTop, scrollLeft} = this._scrollerController!;\n      const {top, left} = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController!.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left,\n      });\n    }\n  }\n\n  public element(index: number): VirtualizerChildElementProxy | undefined {\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return this._items?.[index] === undefined\n      ? undefined\n      : {\n          scrollIntoView: (options: ScrollIntoViewOptions = {}) =>\n            this._scrollElementIntoView({...options, index}),\n        };\n  }\n\n  private _scrollElementIntoView(options: ScrollElementIntoViewOptions) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout!.getScrollIntoViewCoordinates(options);\n        const {behavior} = options;\n        this._updateScrollIntoViewCoordinates =\n          this._scrollerController!.managedScrollTo(\n            Object.assign(coordinates, {behavior}),\n            () => this._layout!.getScrollIntoViewCoordinates(options),\n            () => (this._scrollIntoViewTarget = null)\n          );\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout!.pin = options;\n      }\n    }\n  }\n\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  private _checkScrollIntoViewTarget(pos: ChildPositions | null) {\n    const {index} = this._scrollIntoViewTarget || {};\n    if (index && pos?.has(index)) {\n      this._updateScrollIntoViewCoordinates!(\n        this._layout!.getScrollIntoViewCoordinates(this._scrollIntoViewTarget!)\n      );\n    }\n  }\n\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  private _notifyRange() {\n    this._hostElement!.dispatchEvent(\n      new RangeChangedEvent({first: this._first, last: this._last})\n    );\n  }\n\n  private _notifyVisibility() {\n    this._hostElement!.dispatchEvent(\n      new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible,\n      })\n    );\n  }\n\n  public get layoutComplete(): Promise<void> {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n\n  private _rejectLayoutCompletePromise(reason: string) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() =>\n        requestAnimationFrame(() => this._resolveLayoutCompletePromise())\n      );\n    }\n  }\n\n  private _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  private _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n  private _childLoaded() {}\n\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  private _childrenSizeChanged(changes: ResizeObserverEntry[]) {\n    // Only measure if the layout requires it\n    if (this._layout?.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(\n          change.target as HTMLElement,\n          change.contentRect\n        );\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\n\nfunction getMargins(el: Element): Margins {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft),\n  };\n}\n\nfunction getMarginValue(value: string): number {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el: Element) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return (parentNode as ShadowRoot).host || null;\n  }\n  return null;\n}\n\n///\n\nfunction getElementAncestors(el: HTMLElement, includeSelf = false) {\n  const ancestors: Array<HTMLElement> = [];\n  let parent = includeSelf ? el : (getParentElement(el) as HTMLElement);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent) as HTMLElement;\n  }\n  return ancestors;\n}\n\nfunction getClippingAncestors(el: HTMLElement, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter((a) => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport class RangeChangedEvent extends Event {\n  static eventName = 'rangeChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(RangeChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class VisibilityChangedEvent extends Event {\n  static eventName = 'visibilityChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(VisibilityChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class UnpinnedEvent extends Event {\n  static eventName = 'unpinned';\n\n  constructor() {\n    super(UnpinnedEvent.eventName, {bubbles: false});\n  }\n}\n\ninterface Range {\n  first: number;\n  last: number;\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {LitVirtualizer} from './LitVirtualizer.js';\nexport {LitVirtualizer};\nexport {RangeChangedEvent, VisibilityChangedEvent} from './events.js';\n\n/**\n * Import this module to declare the lit-virtualizer custom element.\n */\ncustomElements.define('lit-virtualizer', LitVirtualizer);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'lit-virtualizer': LitVirtualizer;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {TemplateResult, ChildPart, html, noChange} from 'lit';\nimport {directive, DirectiveResult, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {repeat, KeyFn} from 'lit/directives/repeat.js';\nimport {Virtualizer} from './Virtualizer.js';\nimport {RangeChangedEvent} from './events.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\n\nexport {virtualizerRef, VirtualizerHostElement} from './Virtualizer.js';\n\n/**\n * Configuration options for the virtualize directive.\n */\nexport interface VirtualizeDirectiveConfig<T> {\n  /**\n   * A function that returns a lit-html TemplateResult. It will be used\n   * to generate the DOM for each item in the virtual list.\n   */\n  renderItem?: RenderItemFunction<T>;\n\n  keyFunction?: KeyFn<T>;\n\n  scroller?: boolean;\n\n  // TODO (graynorton): Document...\n  layout?: LayoutConfigValue;\n\n  /**\n   * The list of items to display via the renderItem function.\n   */\n  items?: Array<T>;\n}\n\nexport type RenderItemFunction<T = unknown> = (\n  item: T,\n  index: number\n) => TemplateResult;\n\nexport const defaultKeyFunction: KeyFn<unknown> = (item: unknown) => item;\nexport const defaultRenderItem: RenderItemFunction<unknown> = (\n  item: unknown,\n  idx: number\n) => html`${idx}: ${JSON.stringify(item, null, 2)}`;\n\nclass VirtualizeDirective<T = unknown> extends AsyncDirective {\n  _virtualizer: Virtualizer | null = null;\n  _first = 0;\n  _last = -1;\n  _renderItem: RenderItemFunction<T> = (item: T, idx: number) =>\n    defaultRenderItem(item, idx + this._first);\n  _keyFunction: KeyFn<T> = (item: T, idx: number) =>\n    defaultKeyFunction(item, idx + this._first);\n  _items: Array<T> = [];\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type !== PartType.CHILD) {\n      throw new Error(\n        'The virtualize directive can only be used in child expressions'\n      );\n    }\n  }\n\n  render(config?: VirtualizeDirectiveConfig<T>) {\n    if (config) {\n      this._setFunctions(config);\n    }\n    const itemsToRender: Array<T> = [];\n\n    if (this._first >= 0 && this._last >= this._first) {\n      for (let i = this._first; i <= this._last; i++) {\n        itemsToRender.push(this._items[i]);\n      }\n    }\n    return repeat(itemsToRender, this._keyFunction, this._renderItem);\n  }\n\n  update(part: ChildPart, [config]: [VirtualizeDirectiveConfig<T>]) {\n    this._setFunctions(config);\n    const itemsChanged = this._items !== config.items;\n    this._items = config.items || [];\n    if (this._virtualizer) {\n      this._updateVirtualizerConfig(part, config);\n    } else {\n      this._initialize(part, config);\n    }\n    return itemsChanged ? noChange : this.render();\n  }\n\n  private async _updateVirtualizerConfig(\n    part: ChildPart,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    const compatible = await this._virtualizer!.updateLayoutConfig(\n      config.layout || {}\n    );\n    if (!compatible) {\n      const hostElement = part.parentNode as HTMLElement;\n      this._makeVirtualizer(hostElement, config);\n    }\n    this._virtualizer!.items = this._items;\n  }\n\n  private _setFunctions(config: VirtualizeDirectiveConfig<T>) {\n    const {renderItem, keyFunction} = config;\n    if (renderItem) {\n      this._renderItem = (item, idx) => renderItem(item, idx + this._first);\n    }\n    if (keyFunction) {\n      this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);\n    }\n  }\n\n  private _makeVirtualizer(\n    hostElement: HTMLElement,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    if (this._virtualizer) {\n      this._virtualizer.disconnected();\n    }\n    const {layout, scroller, items} = config;\n    this._virtualizer = new Virtualizer({hostElement, layout, scroller});\n    this._virtualizer.items = items;\n    this._virtualizer.connected();\n  }\n\n  private _initialize(part: ChildPart, config: VirtualizeDirectiveConfig<T>) {\n    const hostElement = part.parentNode as HTMLElement;\n    if (hostElement && hostElement.nodeType === 1) {\n      hostElement.addEventListener('rangeChanged', (e: RangeChangedEvent) => {\n        this._first = e.first;\n        this._last = e.last;\n        this.setValue(this.render());\n      });\n      this._makeVirtualizer(hostElement, config);\n    }\n  }\n\n  disconnected() {\n    this._virtualizer?.disconnected();\n  }\n\n  reconnected() {\n    this._virtualizer?.connected();\n  }\n}\n\nexport const virtualize = directive(VirtualizeDirective) as <T>(\n  config?: VirtualizeDirectiveConfig<T>\n) => DirectiveResult<typeof VirtualizeDirective>;\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Overview:\n *\n * This module is designed to add support for an async `setValue` API and\n * `disconnected` callback to directives with the least impact on the core\n * runtime or payload when that feature is not used.\n *\n * The strategy is to introduce a `AsyncDirective` subclass of\n * `Directive` that climbs the \"parent\" tree in its constructor to note which\n * branches of lit-html's \"logical tree\" of data structures contain such\n * directives and thus need to be crawled when a subtree is being cleared (or\n * manually disconnected) in order to run the `disconnected` callback.\n *\n * The \"nodes\" of the logical tree include Parts, TemplateInstances (for when a\n * TemplateResult is committed to a value of a ChildPart), and Directives; these\n * all implement a common interface called `DisconnectableChild`. Each has a\n * `_$parent` reference which is set during construction in the core code, and a\n * `_$disconnectableChildren` field which is initially undefined.\n *\n * The sparse tree created by means of the `AsyncDirective` constructor\n * crawling up the `_$parent` tree and placing a `_$disconnectableChildren` Set\n * on each parent that includes each child that contains a\n * `AsyncDirective` directly or transitively via its children. In order to\n * notify connection state changes and disconnect (or reconnect) a tree, the\n * `_$notifyConnectionChanged` API is patched onto ChildParts as a directive\n * climbs the parent tree, which is called by the core when clearing a part if\n * it exists. When called, that method iterates over the sparse tree of\n * Set<DisconnectableChildren> built up by AsyncDirectives, and calls\n * `_$notifyDirectiveConnectionChanged` on any directives that are encountered\n * in that tree, running the required callbacks.\n *\n * A given \"logical tree\" of lit-html data-structures might look like this:\n *\n *  ChildPart(N1) _$dC=[D2,T3]\n *   ._directive\n *     AsyncDirective(D2)\n *   ._value // user value was TemplateResult\n *     TemplateInstance(T3) _$dC=[A4,A6,N10,N12]\n *      ._$parts[]\n *        AttributePart(A4) _$dC=[D5]\n *         ._directives[]\n *           AsyncDirective(D5)\n *        AttributePart(A6) _$dC=[D7,D8]\n *         ._directives[]\n *           AsyncDirective(D7)\n *           Directive(D8) _$dC=[D9]\n *            ._directive\n *              AsyncDirective(D9)\n *        ChildPart(N10) _$dC=[D11]\n *         ._directive\n *           AsyncDirective(D11)\n *         ._value\n *           string\n *        ChildPart(N12) _$dC=[D13,N14,N16]\n *         ._directive\n *           AsyncDirective(D13)\n *         ._value // user value was iterable\n *           Array<ChildPart>\n *             ChildPart(N14) _$dC=[D15]\n *              ._value\n *                string\n *             ChildPart(N16) _$dC=[D17,T18]\n *              ._directive\n *                AsyncDirective(D17)\n *              ._value // user value was TemplateResult\n *                TemplateInstance(T18) _$dC=[A19,A21,N25]\n *                 ._$parts[]\n *                   AttributePart(A19) _$dC=[D20]\n *                    ._directives[]\n *                      AsyncDirective(D20)\n *                   AttributePart(A21) _$dC=[22,23]\n *                    ._directives[]\n *                      AsyncDirective(D22)\n *                      Directive(D23) _$dC=[D24]\n *                       ._directive\n *                         AsyncDirective(D24)\n *                   ChildPart(N25) _$dC=[D26]\n *                    ._directive\n *                      AsyncDirective(D26)\n *                    ._value\n *                      string\n *\n * Example 1: The directive in ChildPart(N12) updates and returns `nothing`. The\n * ChildPart will _clear() itself, and so we need to disconnect the \"value\" of\n * the ChildPart (but not its directive). In this case, when `_clear()` calls\n * `_$notifyConnectionChanged()`, we don't iterate all of the\n * _$disconnectableChildren, rather we do a value-specific disconnection: i.e.\n * since the _value was an Array<ChildPart> (because an iterable had been\n * committed), we iterate the array of ChildParts (N14, N16) and run\n * `setConnected` on them (which does recurse down the full tree of\n * `_$disconnectableChildren` below it, and also removes N14 and N16 from N12's\n * `_$disconnectableChildren`). Once the values have been disconnected, we then\n * check whether the ChildPart(N12)'s list of `_$disconnectableChildren` is empty\n * (and would remove it from its parent TemplateInstance(T3) if so), but since\n * it would still contain its directive D13, it stays in the disconnectable\n * tree.\n *\n * Example 2: In the course of Example 1, `setConnected` will reach\n * ChildPart(N16); in this case the entire part is being disconnected, so we\n * simply iterate all of N16's `_$disconnectableChildren` (D17,T18) and\n * recursively run `setConnected` on them. Note that we only remove children\n * from `_$disconnectableChildren` for the top-level values being disconnected\n * on a clear; doing this bookkeeping lower in the tree is wasteful since it's\n * all being thrown away.\n *\n * Example 3: If the LitElement containing the entire tree above becomes\n * disconnected, it will run `childPart.setConnected()` (which calls\n * `childPart._$notifyConnectionChanged()` if it exists); in this case, we\n * recursively run `setConnected()` over the entire tree, without removing any\n * children from `_$disconnectableChildren`, since this tree is required to\n * re-connect the tree, which does the same operation, simply passing\n * `isConnected: true` down the tree, signaling which callback to run.\n */\n\nimport {AttributePart, ChildPart, Disconnectable, Part} from './lit-html.js';\nimport {isSingleExpression} from './directive-helpers.js';\nimport {Directive, PartInfo, PartType} from './directive.js';\nexport * from './directive.js';\n\nconst DEV_MODE = true;\n\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (\n  parent: Disconnectable,\n  isConnected: boolean\n): boolean => {\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (obj as AsyncDirective)['_$notifyDirectiveConnectionChanged']?.(\n      isConnected,\n      false\n    );\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj: Disconnectable) => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren!;\n    children.delete(obj);\n    obj = parent;\n  } while (children?.size === 0);\n};\n\nconst addDisconnectableToParent = (obj: Disconnectable) => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; (parent = obj._$parent); obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(this: ChildPart, newParent: Disconnectable) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(\n  this: ChildPart,\n  isConnected: boolean,\n  isClearingValue = false,\n  fromPartIndex = 0\n) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value as Disconnectable, false);\n      removeDisconnectableFromParent(value as Disconnectable);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj: Disconnectable) => {\n  if ((obj as ChildPart).type == PartType.CHILD) {\n    (obj as ChildPart)._$notifyConnectionChanged ??=\n      notifyChildPartConnectedChanged;\n    (obj as ChildPart)._$reparentDisconnectables ??= reparentDisconnectables;\n  }\n};\n\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport abstract class AsyncDirective extends Directive {\n  // As opposed to other Disconnectables, AsyncDirectives always get notified\n  // when the RootPart connection changes, so the public `isConnected`\n  // is a locally stored variable initialized via its part's getter and synced\n  // via `_$notifyDirectiveConnectionChanged`. This is cheaper than using\n  // the _$isConnected getter, which has to look back up the tree each time.\n  /**\n   * The connection state for this Directive.\n   */\n  isConnected!: boolean;\n\n  // @internal\n  override _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  override _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  override ['_$notifyDirectiveConnectionChanged'](\n    isConnected: boolean,\n    isClearingDirective = true\n  ) {\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        this.reconnected?.();\n      } else {\n        this.disconnected?.();\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value: unknown) {\n    if (isSingleExpression(this.__part as unknown as PartInfo)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...(this.__part._$committedValue as Array<unknown>)];\n      newValues[this.__attributeIndex!] = value;\n      (this.__part as AttributePart)._$setValue(newValues, this, 0);\n    }\n  }\n\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  protected disconnected() {}\n  protected reconnected() {}\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"],"names":["LitVirtualizer","LitElement","createRenderRoot","this","render","items","renderItem","keyFunction","layout","scroller","html","_t","_","virtualize","element","index","_this$virtualizerRef","virtualizerRef","layoutComplete","_this$virtualizerRef2","scrollToIndex","position","_this$element","scrollIntoView","block","constructor","defaultRenderItem","defaultKeyFunction","__decorate","property","attribute","reflect","type","Boolean","ScrollerShim","_element","document","scrollingElement","documentElement","scrollTop","window","scrollY","scrollLeft","scrollX","scrollHeight","scrollWidth","viewportHeight","getBoundingClientRect","height","innerHeight","viewportWidth","width","innerWidth","maxScrollTop","maxScrollLeft","node","_node","ScrollerController","_destination","__destination","scrolling","scrollTo","p1","p2","options","left","top","_scrollTo","scrollBy","undefined","_nativeScrollTo","_originalScrollTo","bind","retarget","end","_end","behavior","_setDestination","_retarget","_resetScrollState","Math","max","min","_updateManagedScrollTo","coordinates","managedScrollTo","correctScrollError","correctingScrollError","requestAnimationFrame","_checkForArrival","topDiff","abs","leftDiff","detach","client","_clients","delete","size","_originalScrollBy","scroll","_originalScroll","removeEventListener","_attach","add","addEventListener","super","Set","_ResizeObserver","ResizeObserver","Symbol","SIZER_ATTRIBUTE","DefaultLayoutConstructor","Virtualizer","Array","isArray","_items","_itemsChanged","_schedule","_updateLayout","_init","config","_isScroller","_initHostElement","layoutConfig","_layoutInitialized","_initLayout","_initObservers","_mutationObserver","MutationObserver","_finishDOMUpdate","_hostElementRO","_hostElementSizeChanged","_childrenRO","_childrenSizeChanged","hostElement","_hostElement","_applyVirtualizerStyles","connected","includeSelf","_clippingAncestors","getClippingAncestors","_scrollerController","_observeAndListen","_connected","observe","childList","_scrollEventListeners","push","_scrollEventListenerOptions","forEach","ancestor","_children","child","target","disconnected","_this$_scrollerContro","_this$_mutationObserv","_this$_hostElementRO","_this$_childrenRO","disconnect","_rejectLayoutCompletePromise","style","display","contain","overflow","minHeight","_getSizer","_sizer","sizer","querySelector","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","textContent","updateLayoutConfig","Ctor","_layout","copy","FlowLayout","message","_handleLayoutMessage","measureChildren","updateItemSizes","_measureChildOverride","_measureCallback","listenForChildLoadEvents","_loadListener","startBenchmarking","_benchmarkStart","performance","now","stopBenchmarking","timeElapsed","virtualizationTime","getEntriesByName","filter","e","startTime","reduce","t","m","duration","_measureChildren","mm","children","fn","_measureChild","i","length","idx","_first","_toBeMeasured","has","call","_childMeasurements","clear","getMargins","method","_scheduled","Promise","resolve","_updateDOM","state","_scrollSize","scrollSize","_adjustRange","range","_childrenPos","childPositions","_scrollError","scrollError","_rangeChanged","_visibilityChanged","_notifyVisibility","_notifyRange","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","mark","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","_this$_layout","unpin","handleEvent","event","currentTarget","includes","_firstVisible","firstVisible","_lastVisible","lastVisible","dispatchEvent","UnpinnedEvent","arr","next","firstElementChild","hasAttribute","nextElementSibling","_this$_scrollerContro2","bottom","right","hostElementBounds","ancestorBounds","map","unshift","bounds","scrollingElementBounds","offsetWithinScroller","totalScrollSize","viewportSize","viewportScroll","h","v","transform","minWidth","pos","xOffset","yOffset","boxSizing","_last","first","last","_this$_items","Infinity","_scrollElementIntoView","getScrollIntoViewCoordinates","_updateScrollIntoViewCoordinates","_scrollIntoViewTarget","pin","RangeChangedEvent","VisibilityChangedEvent","_layoutCompletePromise","reject","_layoutCompleteResolver","_layoutCompleteRejecter","reason","_resetLayoutCompleteState","_scheduleLayoutComplete","_pendingLayoutComplete","_resolveLayoutCompletePromise","_childLoaded","changes","_this$_layout2","change","set","contentRect","Map","passive","WeakSet","Error","el","getComputedStyle","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","value","float","parseFloat","NaN","Number","isNaN","getParentElement","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","getElementAncestors","ancestors","parent","foundFixed","a","Event","eventName","bubbles","customElements","define","item","JSON","stringify","VirtualizeDirective","AsyncDirective","_setFunctions","itemsToRender","repeat","_keyFunction","_renderItem","update","part","itemsChanged","_virtualizer","_updateVirtualizerConfig","_initialize","noChange","_makeVirtualizer","setValue","_this$_virtualizer","reconnected","_this$_virtualizer2","PartType","directive","s","_$AN","_i$_$AO","_$AO","o","_e","_$AM","r","c","n","_$AH","_i$_$AP","_i$_$AQ","_$AP","_$AQ","f","_$AT","isConnected","_$AU","_this$reconnected","_this$disconnected","_$Ct","_$AI","_$Ci","arguments","l","dt","values","keys","_this$ut","d","p","ut","y","x","j","k","w","u","get"],"mappings":"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"}