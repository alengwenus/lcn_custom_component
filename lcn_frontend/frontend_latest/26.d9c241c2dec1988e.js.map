{"version":3,"file":"26.d9c241c2dec1988e.js","sources":["webpack://lcn-frontend/src/events.ts","webpack://lcn-frontend/src/ScrollerController.ts","webpack://lcn-frontend/src/Virtualizer.ts","webpack://lcn-frontend/src/virtualize.ts","webpack://lcn-frontend/src/LitVirtualizer.ts","webpack://lcn-frontend/src/lit-virtualizer.ts","webpack://lcn-frontend/src/async-directive.ts","webpack://lcn-frontend/../src/directives/repeat.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport class RangeChangedEvent extends Event {\n  static eventName = 'rangeChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(RangeChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class VisibilityChangedEvent extends Event {\n  static eventName = 'visibilityChanged';\n\n  first: number;\n  last: number;\n\n  constructor(range: Range) {\n    super(VisibilityChangedEvent.eventName, {bubbles: false});\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\n\nexport class UnpinnedEvent extends Event {\n  static eventName = 'unpinned';\n\n  constructor() {\n    super(UnpinnedEvent.eventName, {bubbles: false});\n  }\n}\n\ninterface Range {\n  first: number;\n  last: number;\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ScrollToCoordinates} from './layouts/shared/Layout.js';\n\ntype retargetScrollCallback = () => ScrollToCoordinates;\ntype endScrollCallback = () => void;\ntype Nullable<T> = T | null;\n\nexport class ScrollerShim {\n  protected _node: Element | Window;\n  protected _element: Nullable<Element> = null;\n\n  constructor(element?: Element) {\n    const node = element ?? window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n\n  public get element() {\n    return (\n      this._element || document.scrollingElement || document.documentElement\n    );\n  }\n\n  public get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n\n  public get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n\n  public get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n\n  public get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n\n  public get viewportHeight() {\n    return this._element\n      ? this._element.getBoundingClientRect().height\n      : window.innerHeight;\n  }\n\n  public get viewportWidth() {\n    return this._element\n      ? this._element.getBoundingClientRect().width\n      : window.innerWidth;\n  }\n\n  public get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n\n  public get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\n\nexport class ScrollerController extends ScrollerShim {\n  private _originalScrollTo:\n    | typeof Element.prototype.scrollTo\n    | typeof window.scrollTo;\n  private _originalScrollBy:\n    | typeof Element.prototype.scrollBy\n    | typeof window.scrollBy;\n  private _originalScroll:\n    | typeof Element.prototype.scroll\n    | typeof window.scroll;\n  private _clients = new Set<unknown>();\n  private _retarget: Nullable<retargetScrollCallback> = null;\n  private _end: Nullable<endScrollCallback> = null;\n  private __destination: Nullable<ScrollToOptions> = null;\n\n  constructor(client: unknown, element?: Element) {\n    super(element);\n\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n\n    const node = this._node;\n\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n\n  public correctingScrollError = false;\n\n  private get _destination() {\n    return this.__destination;\n  }\n\n  public get scrolling() {\n    return this._destination !== null;\n  }\n\n  public scrollTo(options: ScrollToOptions): void;\n  public scrollTo(x: number, y: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    this._scrollTo(options);\n  }\n\n  public scrollBy(options: ScrollToOptions): void;\n  public scrollBy(x: number, y: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n\n  private _nativeScrollTo(options: ScrollToOptions) {\n    this._originalScrollTo!.bind(this._element || window)(options);\n  }\n\n  private _scrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback | null = null,\n    end: endScrollCallback | null = null\n  ) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n\n  private _setDestination(options: ScrollToOptions) {\n    let {top, left} = options;\n    top =\n      top === undefined\n        ? undefined\n        : Math.max(0, Math.min(top, this.maxScrollTop));\n    left =\n      left === undefined\n        ? undefined\n        : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (\n      this._destination !== null &&\n      left === this._destination.left &&\n      top === this._destination.top\n    ) {\n      return false;\n    }\n    this.__destination = {top, left, behavior: 'smooth'};\n    return true;\n  }\n\n  private _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n\n  private _updateManagedScrollTo(coordinates: ScrollToCoordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n\n  public managedScrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback,\n    end: endScrollCallback\n  ) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n\n  public correctScrollError(coordinates: ScrollToCoordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() =>\n      requestAnimationFrame(() => (this.correctingScrollError = false))\n    );\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n\n  private _checkForArrival() {\n    if (this._destination !== null) {\n      const {scrollTop, scrollLeft} = this;\n      let {top, left} = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n\n  public detach(client: unknown) {\n    this._clients.delete(client);\n\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n\n  private _attach(client: unknown) {\n    this._clients.add(client);\n\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client â€“ otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ItemBox,\n  Margins,\n  LayoutConfigValue,\n  ChildPositions,\n  ChildMeasurements,\n  Layout,\n  LayoutConstructor,\n  LayoutSpecifier,\n  StateChangedMessage,\n  Size,\n  InternalRange,\n  MeasureChildFunction,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  LayoutHostMessage,\n} from './layouts/shared/Layout.js';\nimport {\n  RangeChangedEvent,\n  VisibilityChangedEvent,\n  UnpinnedEvent,\n} from './events.js';\nimport {ScrollerController} from './ScrollerController.js';\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver: typeof ResizeObserver | undefined =\n  typeof window !== 'undefined' ? window.ResizeObserver : undefined;\n\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor: typeof ResizeObserver) {\n  _ResizeObserver = Ctor;\n}\n\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    rangeChanged: RangeChangedEvent;\n    visibilityChanged: VisibilityChangedEvent;\n    unpinned: UnpinnedEvent;\n  }\n}\n\nexport interface VirtualizerHostElement extends HTMLElement {\n  [virtualizerRef]?: Virtualizer;\n}\n\n/**\n * A very limited proxy object for a virtualizer child,\n * returned by Virtualizer.element(idx: number). Introduced\n * to enable scrolling a virtual element into view using\n * a call that looks and behaves essentially the same as for\n * a real Element. May be useful for other things later.\n */\nexport interface VirtualizerChildElementProxy {\n  scrollIntoView: (options?: ScrollIntoViewOptions) => void;\n}\n\n/**\n * Used internally for scrolling a (possibly virtual) element\n * into view, given its index\n */\ninterface ScrollElementIntoViewOptions extends ScrollIntoViewOptions {\n  index: number;\n}\n\nexport interface VirtualizerConfig {\n  layout?: LayoutConfigValue;\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n  hostElement: VirtualizerHostElement;\n\n  scroller?: boolean;\n}\n\nlet DefaultLayoutConstructor: LayoutConstructor;\n\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  private _benchmarkStart: number | null = null;\n\n  private _layout: Layout | null = null;\n\n  private _clippingAncestors: HTMLElement[] = [];\n\n  /**\n   * Layout provides these values, we set them on _render().\n   * TODO @straversi: Can we find an XOR type, usable for the key here?\n   */\n  private _scrollSize: Size | null = null;\n\n  /**\n   * Difference between scroll target's current and required scroll offsets.\n   * Provided by layout.\n   */\n  private _scrollError: {left: number; top: number} | null = null;\n\n  /**\n   * A list of the positions (top, left) of the children in the current range.\n   */\n  private _childrenPos: ChildPositions | null = null;\n\n  // TODO: (graynorton): type\n  private _childMeasurements: ChildMeasurements | null = null;\n\n  private _toBeMeasured = new Map<HTMLElement, unknown>();\n\n  private _rangeChanged = true;\n\n  private _itemsChanged = true;\n\n  private _visibilityChanged = true;\n\n  /**\n   * The HTMLElement that hosts the virtualizer. Set by hostElement.\n   */\n  protected _hostElement?: VirtualizerHostElement;\n\n  private _scrollerController: ScrollerController | null = null;\n\n  private _isScroller = false;\n\n  private _sizer: HTMLElement | null = null;\n\n  /**\n   * Resize observer attached to hostElement.\n   */\n  private _hostElementRO: ResizeObserver | null = null;\n\n  /**\n   * Resize observer attached to children.\n   */\n  private _childrenRO: ResizeObserver | null = null;\n\n  private _mutationObserver: MutationObserver | null = null;\n\n  private _scrollEventListeners: (Element | Window)[] = [];\n  private _scrollEventListenerOptions: AddEventListenerOptions = {\n    passive: true,\n  };\n\n  // TODO (graynorton): Rethink, per longer comment below\n\n  private _loadListener = this._childLoaded.bind(this);\n\n  /**\n   * Index of element to scroll into view, plus scroll\n   * behavior options, as imperatively specified via\n   * `element(index).scrollIntoView()`\n   */\n  private _scrollIntoViewTarget: ScrollElementIntoViewOptions | null = null;\n\n  private _updateScrollIntoViewCoordinates:\n    | ((coordinates: ScrollToCoordinates) => void)\n    | null = null;\n\n  /**\n   * Items to render. Set by items.\n   */\n  private _items: Array<unknown> = [];\n\n  /**\n   * Index of the first child in the range, not necessarily the first visible child.\n   * TODO @straversi: Consider renaming these.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child in the range.\n   */\n  protected _last = -1;\n\n  /**\n   * Index of the first item intersecting the viewport.\n   */\n  private _firstVisible = -1;\n\n  /**\n   * Index of the last item intersecting the viewport.\n   */\n  private _lastVisible = -1;\n\n  protected _scheduled = new WeakSet<Function>();\n\n  /**\n   * Invoked at the end of each render cycle: children in the range are\n   * measured, and their dimensions passed to this callback. Use it to layout\n   * children as needed.\n   */\n  protected _measureCallback: ((sizes: ChildMeasurements) => void) | null =\n    null;\n\n  protected _measureChildOverride: MeasureChildFunction | null = null;\n\n  /**\n   * State for `layoutComplete` promise\n   */\n  private _layoutCompletePromise: Promise<void> | null = null;\n  private _layoutCompleteResolver: Function | null = null;\n  private _layoutCompleteRejecter: Function | null = null;\n  private _pendingLayoutComplete: number | null = null;\n\n  /**\n   * Layout initialization is async because we dynamically load\n   * the default layout if none is specified. This state is to track\n   * whether init is complete.\n   */\n  private _layoutInitialized: Promise<void> | null = null;\n\n  /**\n   * Track connection state to guard against errors / unnecessary work\n   */\n  private _connected = false;\n\n  constructor(config: VirtualizerConfig) {\n    if (!config) {\n      throw new Error(\n        'Virtualizer constructor requires a configuration object'\n      );\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error(\n        'Virtualizer configuration requires the \"hostElement\" property'\n      );\n    }\n  }\n\n  set items(items: Array<unknown> | undefined) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config: VirtualizerConfig) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || ({} as BaseLayoutConfig);\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n\n  private _initObservers() {\n    this._mutationObserver = new MutationObserver(\n      this._finishDOMUpdate.bind(this)\n    );\n    this._hostElementRO = new _ResizeObserver!(() =>\n      this._hostElementSizeChanged()\n    );\n    this._childrenRO = new _ResizeObserver!(\n      this._childrenSizeChanged.bind(this)\n    );\n  }\n\n  _initHostElement(config: VirtualizerConfig) {\n    const hostElement = (this._hostElement = config.hostElement);\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(\n      this._hostElement!,\n      includeSelf\n    );\n\n    this._scrollerController = new ScrollerController(\n      this,\n      this._clippingAncestors[0]\n    );\n\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n    this._connected = true;\n  }\n\n  _observeAndListen() {\n    this._mutationObserver!.observe(this._hostElement!, {childList: true});\n    this._hostElementRO!.observe(this._hostElement!);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach((ancestor) => {\n      ancestor.addEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      );\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO!.observe(ancestor);\n    });\n    this._hostElementRO!.observe(this._scrollerController!.element);\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._scrollEventListeners.forEach((target) =>\n      target.addEventListener('scroll', this, this._scrollEventListenerOptions)\n    );\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach((target) =>\n      target.removeEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      )\n    );\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController?.detach(this);\n    this._scrollerController = null;\n    this._mutationObserver?.disconnect();\n    this._mutationObserver = null;\n    this._hostElementRO?.disconnect();\n    this._hostElementRO = null;\n    this._childrenRO?.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n    this._connected = false;\n  }\n\n  private _applyVirtualizerStyles() {\n    const hostElement = this._hostElement!;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style as CSSStyleDeclaration & {contain: string};\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement!;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(\n        `[${SIZER_ATTRIBUTE}]`\n      ) as HTMLElement;\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px',\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n\n  async updateLayoutConfig(layoutConfig: LayoutConfigValue) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor =\n      ((layoutConfig as LayoutSpecifier).type as LayoutConstructor) ||\n      // The new config is compatible with the current layout,\n      // so we update the config and return true to indicate\n      // a successful update\n      DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete config.type;\n      this._layout.config = config as BaseLayoutConfig;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n\n  private async _initLayout(layoutConfig: LayoutConfigValue) {\n    let config: BaseLayoutConfig | undefined;\n    let Ctor: LayoutConstructor | undefined;\n    if (typeof (layoutConfig as LayoutSpecifier).type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = (layoutConfig as LayoutSpecifier).type as LayoutConstructor;\n      // ...while the rest of the specifier is our layout config\n      const copy = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete copy.type;\n      config = copy as BaseLayoutConfig;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig as BaseLayoutConfig;\n    }\n\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n        .FlowLayout as unknown as LayoutConstructor;\n    }\n\n    this._layout = new Ctor(\n      (message: LayoutHostMessage) => this._handleLayoutMessage(message),\n      config\n    );\n\n    if (\n      this._layout.measureChildren &&\n      typeof this._layout.updateItemSizes === 'function'\n    ) {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement!.addEventListener('load', this._loadListener, true);\n    }\n\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName(\n        'uv-virtualizing',\n        'measure'\n      );\n      const virtualizationTime = entries\n        .filter(\n          (e) => e.startTime >= this._benchmarkStart! && e.startTime < now\n        )\n        .reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {timeElapsed, virtualizationTime};\n    }\n    return null;\n  }\n\n  private _measureChildren(): void {\n    const mm: ChildMeasurements = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element: Element): ItemBox {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {width, height} = element.getBoundingClientRect();\n    return Object.assign({width, height}, getMargins(element));\n  }\n\n  protected async _schedule(method: Function): Promise<void> {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n\n  async _updateDOM(state: StateChangedMessage) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {_rangeChanged, _itemsChanged} = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n\n  _finishDOMUpdate() {\n    if (this._connected) {\n      // _childrenRO should be non-null if we're connected\n      this._children.forEach((child) => this._childrenRO!.observe(child));\n      this._checkScrollIntoViewTarget(this._childrenPos);\n      this._positionChildren(this._childrenPos);\n      this._sizeHostElement(this._scrollSize);\n      this._correctScrollError();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  _updateLayout() {\n    if (this._layout && this._connected) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  private _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController!.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      this._layout?.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event: CustomEvent) {\n    switch (event.type) {\n      case 'scroll':\n        if (\n          event.currentTarget === window ||\n          this._clippingAncestors.includes(event.currentTarget as HTMLElement)\n        ) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  _handleLayoutMessage(message: LayoutHostMessage) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement!.dispatchEvent(new UnpinnedEvent());\n    }\n  }\n\n  get _children(): Array<HTMLElement> {\n    const arr: Array<HTMLElement> = [];\n    let next = this._hostElement!.firstElementChild as HTMLElement;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling as HTMLElement;\n    }\n    return arr;\n  }\n\n  private _updateView() {\n    const hostElement = this._hostElement;\n    const scrollingElement = this._scrollerController?.element;\n    const layout = this._layout;\n\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n\n      const hostElementBounds = hostElement.getBoundingClientRect();\n\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n\n      const ancestorBounds = this._clippingAncestors.map((ancestor) =>\n        ancestor.getBoundingClientRect()\n      );\n      ancestorBounds.unshift(hostElementBounds);\n\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top,\n      };\n\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight,\n      };\n\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n\n      const height = Math.max(0, bottom - top);\n      const width = Math.max(0, right - left);\n\n      layout.viewportSize = {width, height};\n      layout.viewportScroll = {top: scrollTop, left: scrollLeft};\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  private _sizeHostElement(size?: Size | null) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement!.style;\n      (style.minWidth as string | null) = h ? `${h}px` : '100%';\n      (style.minHeight as string | null) = v ? `${v}px` : '100%';\n    }\n  }\n\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  private _positionChildren(pos: ChildPositions | null) {\n    if (pos) {\n      pos.forEach(({top, left, width, height, xOffset, yOffset}, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          (child.style.left as string | null) =\n            xOffset === undefined ? null : xOffset + 'px';\n          (child.style.top as string | null) =\n            yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  private async _adjustRange(range: InternalRange) {\n    const {_first, _last, _firstVisible, _lastVisible} = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged =\n      this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged =\n      this._visibilityChanged ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible;\n  }\n\n  private _correctScrollError() {\n    if (this._scrollError) {\n      const {scrollTop, scrollLeft} = this._scrollerController!;\n      const {top, left} = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController!.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left,\n      });\n    }\n  }\n\n  public element(index: number): VirtualizerChildElementProxy | undefined {\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return this._items?.[index] === undefined\n      ? undefined\n      : {\n          scrollIntoView: (options: ScrollIntoViewOptions = {}) =>\n            this._scrollElementIntoView({...options, index}),\n        };\n  }\n\n  private _scrollElementIntoView(options: ScrollElementIntoViewOptions) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout!.getScrollIntoViewCoordinates(options);\n        const {behavior} = options;\n        this._updateScrollIntoViewCoordinates =\n          this._scrollerController!.managedScrollTo(\n            Object.assign(coordinates, {behavior}),\n            () => this._layout!.getScrollIntoViewCoordinates(options),\n            () => (this._scrollIntoViewTarget = null)\n          );\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout!.pin = options;\n      }\n    }\n  }\n\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  private _checkScrollIntoViewTarget(pos: ChildPositions | null) {\n    const {index} = this._scrollIntoViewTarget || {};\n    if (index && pos?.has(index)) {\n      this._updateScrollIntoViewCoordinates!(\n        this._layout!.getScrollIntoViewCoordinates(this._scrollIntoViewTarget!)\n      );\n    }\n  }\n\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  private _notifyRange() {\n    this._hostElement!.dispatchEvent(\n      new RangeChangedEvent({first: this._first, last: this._last})\n    );\n  }\n\n  private _notifyVisibility() {\n    this._hostElement!.dispatchEvent(\n      new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible,\n      })\n    );\n  }\n\n  public get layoutComplete(): Promise<void> {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n\n  private _rejectLayoutCompletePromise(reason: string) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() =>\n        requestAnimationFrame(() => this._resolveLayoutCompletePromise())\n      );\n    }\n  }\n\n  private _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  private _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n  private _childLoaded() {}\n\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  private _childrenSizeChanged(changes: ResizeObserverEntry[]) {\n    // Only measure if the layout requires it\n    if (this._layout?.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(\n          change.target as HTMLElement,\n          change.contentRect\n        );\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\n\nfunction getMargins(el: Element): Margins {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft),\n  };\n}\n\nfunction getMarginValue(value: string): number {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el: Element) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return (parentNode as ShadowRoot).host || null;\n  }\n  return null;\n}\n\n///\n\nfunction getElementAncestors(el: HTMLElement, includeSelf = false) {\n  const ancestors: Array<HTMLElement> = [];\n  let parent = includeSelf ? el : (getParentElement(el) as HTMLElement);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent) as HTMLElement;\n  }\n  return ancestors;\n}\n\nfunction getClippingAncestors(el: HTMLElement, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter((a) => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {TemplateResult, ChildPart, html, noChange} from 'lit';\nimport {directive, DirectiveResult, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\nimport {repeat, KeyFn} from 'lit/directives/repeat.js';\nimport {Virtualizer} from './Virtualizer.js';\nimport {RangeChangedEvent} from './events.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\n\nexport {virtualizerRef, VirtualizerHostElement} from './Virtualizer.js';\n\n/**\n * Configuration options for the virtualize directive.\n */\nexport interface VirtualizeDirectiveConfig<T> {\n  /**\n   * A function that returns a lit-html TemplateResult. It will be used\n   * to generate the DOM for each item in the virtual list.\n   */\n  renderItem?: RenderItemFunction<T>;\n\n  keyFunction?: KeyFn<T>;\n\n  scroller?: boolean;\n\n  // TODO (graynorton): Document...\n  layout?: LayoutConfigValue;\n\n  /**\n   * The list of items to display via the renderItem function.\n   */\n  items?: Array<T>;\n}\n\nexport type RenderItemFunction<T = unknown> = (\n  item: T,\n  index: number\n) => TemplateResult;\n\nexport const defaultKeyFunction: KeyFn<unknown> = (item: unknown) => item;\nexport const defaultRenderItem: RenderItemFunction<unknown> = (\n  item: unknown,\n  idx: number\n) => html`${idx}: ${JSON.stringify(item, null, 2)}`;\n\nclass VirtualizeDirective<T = unknown> extends AsyncDirective {\n  _virtualizer: Virtualizer | null = null;\n  _first = 0;\n  _last = -1;\n  _renderItem: RenderItemFunction<T> = (item: T, idx: number) =>\n    defaultRenderItem(item, idx + this._first);\n  _keyFunction: KeyFn<T> = (item: T, idx: number) =>\n    defaultKeyFunction(item, idx + this._first);\n  _items: Array<T> = [];\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type !== PartType.CHILD) {\n      throw new Error(\n        'The virtualize directive can only be used in child expressions'\n      );\n    }\n  }\n\n  render(config?: VirtualizeDirectiveConfig<T>) {\n    if (config) {\n      this._setFunctions(config);\n    }\n    const itemsToRender: Array<T> = [];\n\n    if (this._first >= 0 && this._last >= this._first) {\n      for (let i = this._first; i <= this._last; i++) {\n        itemsToRender.push(this._items[i]);\n      }\n    }\n    return repeat(itemsToRender, this._keyFunction, this._renderItem);\n  }\n\n  update(part: ChildPart, [config]: [VirtualizeDirectiveConfig<T>]) {\n    this._setFunctions(config);\n    const itemsChanged = this._items !== config.items;\n    this._items = config.items || [];\n    if (this._virtualizer) {\n      this._updateVirtualizerConfig(part, config);\n    } else {\n      this._initialize(part, config);\n    }\n    return itemsChanged ? noChange : this.render();\n  }\n\n  private async _updateVirtualizerConfig(\n    part: ChildPart,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    const compatible = await this._virtualizer!.updateLayoutConfig(\n      config.layout || {}\n    );\n    if (!compatible) {\n      const hostElement = part.parentNode as HTMLElement;\n      this._makeVirtualizer(hostElement, config);\n    }\n    this._virtualizer!.items = this._items;\n  }\n\n  private _setFunctions(config: VirtualizeDirectiveConfig<T>) {\n    const {renderItem, keyFunction} = config;\n    if (renderItem) {\n      this._renderItem = (item, idx) => renderItem(item, idx + this._first);\n    }\n    if (keyFunction) {\n      this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);\n    }\n  }\n\n  private _makeVirtualizer(\n    hostElement: HTMLElement,\n    config: VirtualizeDirectiveConfig<T>\n  ) {\n    if (this._virtualizer) {\n      this._virtualizer.disconnected();\n    }\n    const {layout, scroller, items} = config;\n    this._virtualizer = new Virtualizer({hostElement, layout, scroller});\n    this._virtualizer.items = items;\n    this._virtualizer.connected();\n  }\n\n  private _initialize(part: ChildPart, config: VirtualizeDirectiveConfig<T>) {\n    const hostElement = part.parentNode as HTMLElement;\n    if (hostElement && hostElement.nodeType === 1) {\n      hostElement.addEventListener('rangeChanged', (e: RangeChangedEvent) => {\n        this._first = e.first;\n        this._last = e.last;\n        this.setValue(this.render());\n      });\n      this._makeVirtualizer(hostElement, config);\n    }\n  }\n\n  disconnected() {\n    this._virtualizer?.disconnected();\n  }\n\n  reconnected() {\n    this._virtualizer?.connected();\n  }\n}\n\nexport const virtualize = directive(VirtualizeDirective) as <T>(\n  config?: VirtualizeDirectiveConfig<T>\n) => DirectiveResult<typeof VirtualizeDirective>;\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {html, LitElement} from 'lit';\nimport {property} from 'lit/decorators/property.js';\nimport {KeyFn} from 'lit/directives/repeat.js';\nimport {LayoutConfigValue} from './layouts/shared/Layout.js';\nimport {\n  virtualize,\n  virtualizerRef,\n  VirtualizerHostElement,\n  defaultRenderItem,\n  defaultKeyFunction,\n  RenderItemFunction,\n} from './virtualize.js';\n\nexport class LitVirtualizer<T = unknown> extends LitElement {\n  @property({attribute: false})\n  items: T[] = [];\n\n  @property()\n  renderItem: RenderItemFunction<T> = defaultRenderItem;\n\n  @property()\n  keyFunction: KeyFn<T> = defaultKeyFunction;\n\n  @property({attribute: false})\n  layout: LayoutConfigValue = {};\n\n  @property({reflect: true, type: Boolean})\n  scroller = false;\n\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    const {items, renderItem, keyFunction, layout, scroller} = this;\n    return html`${virtualize({\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller,\n    })}`;\n  }\n\n  element(index: number) {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.element(index);\n  }\n\n  get layoutComplete() {\n    return (this as VirtualizerHostElement)[virtualizerRef]?.layoutComplete;\n  }\n\n  /**\n   * This scrollToIndex() shim is here to provide backwards compatibility with other 0.x versions of\n   * lit-virtualizer. It is deprecated and will likely be removed in the 1.0.0 release.\n   */\n  scrollToIndex(\n    index: number,\n    position: 'start' | 'center' | 'end' | 'nearest' = 'start'\n  ) {\n    this.element(index)?.scrollIntoView({block: position});\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {LitVirtualizer} from './LitVirtualizer.js';\nexport {LitVirtualizer};\nexport {RangeChangedEvent, VisibilityChangedEvent} from './events.js';\n\n/**\n * Import this module to declare the lit-virtualizer custom element.\n */\ncustomElements.define('lit-virtualizer', LitVirtualizer);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'lit-virtualizer': LitVirtualizer;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Overview:\n *\n * This module is designed to add support for an async `setValue` API and\n * `disconnected` callback to directives with the least impact on the core\n * runtime or payload when that feature is not used.\n *\n * The strategy is to introduce a `AsyncDirective` subclass of\n * `Directive` that climbs the \"parent\" tree in its constructor to note which\n * branches of lit-html's \"logical tree\" of data structures contain such\n * directives and thus need to be crawled when a subtree is being cleared (or\n * manually disconnected) in order to run the `disconnected` callback.\n *\n * The \"nodes\" of the logical tree include Parts, TemplateInstances (for when a\n * TemplateResult is committed to a value of a ChildPart), and Directives; these\n * all implement a common interface called `DisconnectableChild`. Each has a\n * `_$parent` reference which is set during construction in the core code, and a\n * `_$disconnectableChildren` field which is initially undefined.\n *\n * The sparse tree created by means of the `AsyncDirective` constructor\n * crawling up the `_$parent` tree and placing a `_$disconnectableChildren` Set\n * on each parent that includes each child that contains a\n * `AsyncDirective` directly or transitively via its children. In order to\n * notify connection state changes and disconnect (or reconnect) a tree, the\n * `_$notifyConnectionChanged` API is patched onto ChildParts as a directive\n * climbs the parent tree, which is called by the core when clearing a part if\n * it exists. When called, that method iterates over the sparse tree of\n * Set<DisconnectableChildren> built up by AsyncDirectives, and calls\n * `_$notifyDirectiveConnectionChanged` on any directives that are encountered\n * in that tree, running the required callbacks.\n *\n * A given \"logical tree\" of lit-html data-structures might look like this:\n *\n *  ChildPart(N1) _$dC=[D2,T3]\n *   ._directive\n *     AsyncDirective(D2)\n *   ._value // user value was TemplateResult\n *     TemplateInstance(T3) _$dC=[A4,A6,N10,N12]\n *      ._$parts[]\n *        AttributePart(A4) _$dC=[D5]\n *         ._directives[]\n *           AsyncDirective(D5)\n *        AttributePart(A6) _$dC=[D7,D8]\n *         ._directives[]\n *           AsyncDirective(D7)\n *           Directive(D8) _$dC=[D9]\n *            ._directive\n *              AsyncDirective(D9)\n *        ChildPart(N10) _$dC=[D11]\n *         ._directive\n *           AsyncDirective(D11)\n *         ._value\n *           string\n *        ChildPart(N12) _$dC=[D13,N14,N16]\n *         ._directive\n *           AsyncDirective(D13)\n *         ._value // user value was iterable\n *           Array<ChildPart>\n *             ChildPart(N14) _$dC=[D15]\n *              ._value\n *                string\n *             ChildPart(N16) _$dC=[D17,T18]\n *              ._directive\n *                AsyncDirective(D17)\n *              ._value // user value was TemplateResult\n *                TemplateInstance(T18) _$dC=[A19,A21,N25]\n *                 ._$parts[]\n *                   AttributePart(A19) _$dC=[D20]\n *                    ._directives[]\n *                      AsyncDirective(D20)\n *                   AttributePart(A21) _$dC=[22,23]\n *                    ._directives[]\n *                      AsyncDirective(D22)\n *                      Directive(D23) _$dC=[D24]\n *                       ._directive\n *                         AsyncDirective(D24)\n *                   ChildPart(N25) _$dC=[D26]\n *                    ._directive\n *                      AsyncDirective(D26)\n *                    ._value\n *                      string\n *\n * Example 1: The directive in ChildPart(N12) updates and returns `nothing`. The\n * ChildPart will _clear() itself, and so we need to disconnect the \"value\" of\n * the ChildPart (but not its directive). In this case, when `_clear()` calls\n * `_$notifyConnectionChanged()`, we don't iterate all of the\n * _$disconnectableChildren, rather we do a value-specific disconnection: i.e.\n * since the _value was an Array<ChildPart> (because an iterable had been\n * committed), we iterate the array of ChildParts (N14, N16) and run\n * `setConnected` on them (which does recurse down the full tree of\n * `_$disconnectableChildren` below it, and also removes N14 and N16 from N12's\n * `_$disconnectableChildren`). Once the values have been disconnected, we then\n * check whether the ChildPart(N12)'s list of `_$disconnectableChildren` is empty\n * (and would remove it from its parent TemplateInstance(T3) if so), but since\n * it would still contain its directive D13, it stays in the disconnectable\n * tree.\n *\n * Example 2: In the course of Example 1, `setConnected` will reach\n * ChildPart(N16); in this case the entire part is being disconnected, so we\n * simply iterate all of N16's `_$disconnectableChildren` (D17,T18) and\n * recursively run `setConnected` on them. Note that we only remove children\n * from `_$disconnectableChildren` for the top-level values being disconnected\n * on a clear; doing this bookkeeping lower in the tree is wasteful since it's\n * all being thrown away.\n *\n * Example 3: If the LitElement containing the entire tree above becomes\n * disconnected, it will run `childPart.setConnected()` (which calls\n * `childPart._$notifyConnectionChanged()` if it exists); in this case, we\n * recursively run `setConnected()` over the entire tree, without removing any\n * children from `_$disconnectableChildren`, since this tree is required to\n * re-connect the tree, which does the same operation, simply passing\n * `isConnected: true` down the tree, signaling which callback to run.\n */\n\nimport {AttributePart, ChildPart, Disconnectable, Part} from './lit-html.js';\nimport {isSingleExpression} from './directive-helpers.js';\nimport {Directive, PartInfo, PartType} from './directive.js';\nexport * from './directive.js';\n\nconst DEV_MODE = true;\n\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (\n  parent: Disconnectable,\n  isConnected: boolean\n): boolean => {\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (obj as AsyncDirective)['_$notifyDirectiveConnectionChanged']?.(\n      isConnected,\n      false\n    );\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj: Disconnectable) => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren!;\n    children.delete(obj);\n    obj = parent;\n  } while (children?.size === 0);\n};\n\nconst addDisconnectableToParent = (obj: Disconnectable) => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; (parent = obj._$parent); obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(this: ChildPart, newParent: Disconnectable) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(\n  this: ChildPart,\n  isConnected: boolean,\n  isClearingValue = false,\n  fromPartIndex = 0\n) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value as Disconnectable, false);\n      removeDisconnectableFromParent(value as Disconnectable);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj: Disconnectable) => {\n  if ((obj as ChildPart).type == PartType.CHILD) {\n    (obj as ChildPart)._$notifyConnectionChanged ??=\n      notifyChildPartConnectedChanged;\n    (obj as ChildPart)._$reparentDisconnectables ??= reparentDisconnectables;\n  }\n};\n\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport abstract class AsyncDirective extends Directive {\n  // As opposed to other Disconnectables, AsyncDirectives always get notified\n  // when the RootPart connection changes, so the public `isConnected`\n  // is a locally stored variable initialized via its part's getter and synced\n  // via `_$notifyDirectiveConnectionChanged`. This is cheaper than using\n  // the _$isConnected getter, which has to look back up the tree each time.\n  /**\n   * The connection state for this Directive.\n   */\n  isConnected!: boolean;\n\n  // @internal\n  override _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  override _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  override ['_$notifyDirectiveConnectionChanged'](\n    isConnected: boolean,\n    isClearingDirective = true\n  ) {\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        this.reconnected?.();\n      } else {\n        this.disconnected?.();\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value: unknown) {\n    if (isSingleExpression(this.__part as unknown as PartInfo)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...(this.__part._$committedValue as Array<unknown>)];\n      newValues[this.__attributeIndex!] = value;\n      (this.__part as AttributePart)._$setValue(newValues, this, 0);\n    }\n  }\n\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  protected disconnected() {}\n  protected reconnected() {}\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"],"names":["RangeChangedEvent","Event","constructor","range","super","eventName","bubbles","this","first","last","VisibilityChangedEvent","UnpinnedEvent","ScrollerShim","element","_element","document","scrollingElement","documentElement","scrollTop","window","scrollY","scrollLeft","scrollX","scrollHeight","scrollWidth","viewportHeight","getBoundingClientRect","height","innerHeight","viewportWidth","width","innerWidth","maxScrollTop","maxScrollLeft","node","_node","ScrollerController","_destination","__destination","scrolling","scrollTo","p1","p2","options","left","top","_scrollTo","scrollBy","undefined","_nativeScrollTo","_originalScrollTo","bind","retarget","end","_end","behavior","_setDestination","_retarget","_resetScrollState","Math","max","min","_updateManagedScrollTo","coordinates","managedScrollTo","correctScrollError","correctingScrollError","requestAnimationFrame","_checkForArrival","topDiff","abs","leftDiff","detach","client","_clients","delete","size","_originalScrollBy","scroll","_originalScroll","removeEventListener","_attach","add","addEventListener","Set","_ResizeObserver","ResizeObserver","virtualizerRef","Symbol","SIZER_ATTRIBUTE","DefaultLayoutConstructor","Virtualizer","items","Array","isArray","_items","_itemsChanged","_schedule","_updateLayout","_init","config","_isScroller","scroller","_initHostElement","layoutConfig","layout","_layoutInitialized","_initLayout","_initObservers","_mutationObserver","MutationObserver","_finishDOMUpdate","_hostElementRO","_hostElementSizeChanged","_childrenRO","_childrenSizeChanged","hostElement","_hostElement","_applyVirtualizerStyles","connected","includeSelf","_clippingAncestors","el","foundFixed","ancestors","parent","getParentElement","push","getElementAncestors","filter","a","style","getComputedStyle","position","overflow","getClippingAncestors","_scrollerController","_observeAndListen","_connected","observe","childList","_scrollEventListeners","_scrollEventListenerOptions","forEach","ancestor","_children","child","target","disconnected","disconnect","_rejectLayoutCompletePromise","display","contain","minHeight","_getSizer","_sizer","sizer","querySelector","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","textContent","updateLayoutConfig","Ctor","type","_layout","copy","FlowLayout","message","_handleLayoutMessage","measureChildren","updateItemSizes","_measureChildOverride","_measureCallback","listenForChildLoadEvents","_loadListener","startBenchmarking","_benchmarkStart","performance","now","stopBenchmarking","timeElapsed","virtualizationTime","getEntriesByName","e","startTime","reduce","t","m","duration","_measureChildren","mm","children","fn","_measureChild","i","length","idx","_first","_toBeMeasured","has","call","_childMeasurements","clear","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","getMargins","method","_scheduled","Promise","resolve","_updateDOM","state","_scrollSize","scrollSize","_adjustRange","_childrenPos","childPositions","_scrollError","scrollError","_rangeChanged","_visibilityChanged","_notifyVisibility","_notifyRange","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","mark","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","unpin","handleEvent","event","currentTarget","includes","_firstVisible","firstVisible","_lastVisible","lastVisible","dispatchEvent","arr","next","firstElementChild","hasAttribute","nextElementSibling","bottom","right","hostElementBounds","ancestorBounds","map","unshift","bounds","scrollingElementBounds","offsetWithinScroller","totalScrollSize","viewportSize","viewportScroll","h","v","transform","minWidth","pos","xOffset","yOffset","index","boxSizing","_last","Infinity","scrollIntoView","_scrollElementIntoView","getScrollIntoViewCoordinates","_updateScrollIntoViewCoordinates","_scrollIntoViewTarget","pin","layoutComplete","_layoutCompletePromise","reject","_layoutCompleteResolver","_layoutCompleteRejecter","reason","_resetLayoutCompleteState","_scheduleLayoutComplete","_pendingLayoutComplete","_resolveLayoutCompletePromise","_childLoaded","changes","change","set","contentRect","Map","passive","WeakSet","Error","value","float","parseFloat","NaN","Number","isNaN","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","defaultKeyFunction","item","defaultRenderItem","html","JSON","stringify","VirtualizeDirective","AsyncDirective","render","_setFunctions","itemsToRender","repeat","_keyFunction","_renderItem","update","part","itemsChanged","_virtualizer","_updateVirtualizerConfig","_initialize","noChange","_makeVirtualizer","renderItem","keyFunction","setValue","reconnected","PartType","virtualize","directive","LitVirtualizer","LitElement","createRenderRoot","scrollToIndex","block","__decorate","property","attribute","reflect","Boolean","customElements","define","s","_$AN","_$AO","o","_$AM","r","c","n","_$AH","_$AP","_$AQ","f","_$AT","isConnected","_$AU","_$Ct","_$AI","_$Ci","arguments","l","dt","values","keys","d","p","ut","y","x","j","k","w","u","get"],"mappings":"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"}